---
title: 链表知识点梳理
mathjax: true
date: 2021-9-9 22:20:05 
tags: 链表
categories: [数据结构与算法,基础数据结构]
---

## 前言

>  以下是个人对链表的一些知识点的梳理和OJ题型整理。
>
>  本文将以链表中的核心操作（函数）以及这些操作衍生出的一些操作为主线的逻辑主线整理。

<!--more-->

## 概览

![ListSummary](https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/Algorithms/Leetcode/ListSummary.png)

## 特点

链表和数组一样，都是一种基础的线性结构。

### 结构特点

不同的是，链表中两个逻辑相邻的元素，物理地址一般来说都是不相等的。

我们可以把每个元素看成一个个独立的节点，节点中包含着指向下一个节点的指针，这些指针把节点连接起来形成了链状结构，链表之名由此而来。



/**********************************此处有一张数组与链表的结构对比图*********************************************/



## 常见操作

由于平时做题和面试中一般都是单链表，且它最简单，所以以下链表操作皆为单链表。

### 核心操作

#### 初始化

想要对链表进行操作，首先我们得先有链表才行，所以要做的第一件事就是创建一条链表，即初始化。

首先，根据上面提到关于链表结构特点的定义，我们很容易可以写出下面的结构体：

~~~c
typedef struct ListNode{
	int data;
    ListNode *next;
} ListNode;
~~~

然后，我们一般还会定义一个<code>List</code>结构体作为链表的头结点：

```c
typedef struct List{
    ListNode *next;
} List;
```

有的朋友可能会问：既然链表是多个节点通过指针串起来的链状结构，那么我们有<code>ListNode</code> 这一个结构体不就够了吗？为什么还要多此一举搞个<code>List </code>?

问的好，请给一丢丢耐心，先保留下你的疑惑，它的用处等下我们会揭晓。

好，偶们继续。既然节点定义好了，那么接下来就可以写初始化函数了。

~~~c
List* InitList(){
	List *head = (List*)malloc(sizeof(List));
	head->next = NULL;
    return head;
}
~~~

当我们调用 <code>InitList</code> 时，一个链表头就被我们创建了。（当然，你调用这个函数的时候得拿一个List指针变量去接住它的返回值。）



/**********************************此处有一张链表头的结构图*********************************************/



#### 增删改查

所有数据结构中，最核心的操作无非就是增删改查问题。

即：

- 我们应该怎么往这种结构中添加新的数据？
- 怎么删除这个结构中我们指定的数据？ 
- 怎么对指定元素的数据进行修改 ？
- 怎么查找指定的元素？

对应到链表中来的话就是：

- 插入节点
- 删除节点
- 修改节点
- 查找节点

四个操作了。而其中在这里我们只要能找到指定节点，就能修改节点。所以其实我们要实现的操作只有三个。

##### 插入节点

首先，我们先来耍耍插入操作。对于插入操作，我们大概需要注意以下两点：

- 插入的位置是否合法？
- 往已有节点的链表中插入节点时，指针指向应该如何变化？

下面实现了一个向链表L的第n个位置插入值为x的节点的操作。（PS：这里的位置n从1开始计数，即n为1时，头结点指向新插入元素。

```c
int Insert(List *L,int n,int x)//返回值表示是否插入成功
{
    if( n > Len(L)+1)return 0;	//这里的 Len()为求链表长度函数，具体实现且往后看
    
	ListNode *New = (ListNode*)malloc(sizeof(ListNode));	//创建新节点
    New -> data = x;
    
    List *p = find(L,n-1);	//找到插入位置n的前一个节点，find()的具体实现且往后看
    
    New->next = p->next;
    p->next = New->next;
    
    return 1;
}
```



/**********************************此处有两张链表插入节点示意图*******************************************/



##### 删除节点

删除节点和插入节点类似，唯一需要注意的是：**记得释放被删节点内存！！！**

/**********************************此处有两张链表删除节点示意图*******************************************/

 

```c
int Delete(List *L,int n){
    if(n > Len(L)) return 0;
    
	ListNode *p = find(L,n-1); 	//找到被删节点的前一个节点
    ListNode *t = p->next; //临时保存预删节点
    p->next = t->next;
    return 1;
}
```

##### 查找节点

因为链表地址的不连续的特性，所以获取链表中某个**位置**的结点就成为了刚需。这点从上面两个操作中都调用了 **查找指定节点** <code>find()</code> 也可以看出来。

当然除了查找链表中节点的位置，查找链表中是否存在我们想要的那个值（数据），也是很重要的一环。所以对于链表而言 <code>find()</code> 其实有以下两种：

- FindKey() :查找节点的位置，返回的是指定位置的节点指针。
- FindVal()：查找链表中是否存在指定的值（数据），返回值同上。

首先，我们先来实现<code>FindKey()</code> :

~~~c
ListNode* FindKey(List *L ,int n){
    if(L==NULL || L->next==NULL) return NULL; //如果链表为空，就不用找了。
    
	int len = ListSize(L); 
    if(n>len) return NULL; //如果指定位置比链表长度还长，那也不用找了。
    
    ListNode *p = L->next;
    while(--n)p = p->next; //从头结点开始遍历，找到指定在位置n上的节点。
    return p;
}
/****************************************************************
	小结一下流程：
		1、先判断传进来的链表是否为空，减少不必要的操作。
		2、判断指定的节点位置，是否比链表长，如果是的话也没必要操作了。
		3、在链表范围内依图索骥跟着找到指定的节点即可。
*****************************************************************/
~~~

而对于<code>FindVal()</code> 这个操作就很简单啦~

```c
ListNode* FindVal(List *L,int val){
   if(L==NULL || L->next==NULL) return NULL; //如果链表为空，就不用找了。
    
    ListNode *p = L->next;
    while(p && p->data !=val)p = p->next;
    
    return p->data == val? p : -1;
}
/****************************************************************
	小结一下流程：
		1、先判断传进来的链表是否为空，减少不必要的操作。
		2、不停移动节点，直到找到节点or链表遍历完为止。
		3、判断一下当前节点p的数据是否与val相等，相等的话就证明找到了，
		   找不到的话，就返回-1。
*****************************************************************/
```

### 衍生操作

#### 链表长度

获取长度最常见的方式就是把链表遍历一遍。

```c
int Len(List *L){
    if(IsEmpty(L))return 0;
    
    ListNode *p = L->next;
    int len = 0;
    while(p){
        len++;
        p = p->next;
    }
    return len;
}
```

#### 链表判空

这个无脑，直接查看<code>List</code> 的next是否为空即可。

```c
int IsEmpty(List *L){
    return !L || L->next==NULL;
}
```

至此，关于链表的基本操作就介绍完毕了，下面让我们看看经常遇到遇到的一些问题。

## 常见问题and链表变形

### 头结点/哨兵节点

首先，我们先来解决一下前面的遗留问题——为什么需要头结点？头结点有啥用？

先上结论：

1. 可以简化条件判断。
2. 保持链表地址不变。
3. 头结点可以让链表实现部分OOP特性。

现在让我们瞄瞄上述优点它是如何体现的。

先回顾一下，上面有头结点时的插入写法：

```c
int Insert(List *L,int n,int x)//返回值表示是否插入成功
{
    if( n > Len(L)+1)return 0;	//这里的 Len()为求链表长度函数，具体实现且往后看
    
	ListNode *New = (ListNode*)malloc(sizeof(ListNode));	//创建新节点
    New -> data = x;
    
    List *p = find(L,n-1);	//找到插入位置n的前一个节点，find()的具体实现且往后看
    
    New->next = p->next;
    p->next = New->next;
    
    return 1;
}
```

逻辑看上去十分简单清晰明了是不是？那么我们再来看看不用头结点的情况：



### 双向链表

### 循环链表



## 静态链表



## 基础问题

LeetCode [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/) 

LeetCode [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/) //两种方法

LeetCode [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/) 

LeetCode [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

LeetCode [202. 快乐数](https://leetcode-cn.com/problems/happy-number/)

LeetCode [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

LeetCode [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

LeetCode  [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)	//三种方法

## others

LeetCode [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

LeetCode [445. 两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/)

LeetCode [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

LeetCode [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)

LeetCode [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

LeetCode [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)                                                               

LeetCode [708. 排序的循环链表](https://leetcode-cn.com/problems/4ueAj6/)

LeetCode [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

LeetCode [430. 扁平化多级双向链表](https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/)



