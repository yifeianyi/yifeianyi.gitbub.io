# 数论初步（一）

# 前言

> 数论作为纯粹的数学分支之一，它的抽象注定了这个学科分支具有不低的劝退能力。
>
> 但很多时候，在一些实际问题的拆解过程中，拆到最后会发现还是简单的基础数论问题。这些问题单独看的话可能不太起眼，但融合到其它问题中成为一个小模块时还是挺膈应人。
>
> 以下是本人简单总结的一些常用的数论基础知识。



# 质数相关

## 定义

balablablablalbal

## 常见问题

1. 判断一个数是否是质数
2. 得出一个数的所有质因数

而问题2，其实是问题1的简单应用延展，所以我们只需要解决如何判断一个数是否是质数即可。

## 判质数的场景

对于这个问题，根据使用场景的不同，可以细分为以下两种情况：

- 需要做判断的频率不高，甚至短时间内只需要判断一次
- 短时间内需要频繁使用多个不同的质数

对于第一种情况，我们一般会直接使用试除法。

## 试除法判素数

**模板题：**[AcWing 866. 试除法判定质数](https://www.acwing.com/problem/content/868/)

原理上试除法没什么可说的，说白了就是从1开始从小到大暴力枚举所有数，判断所枚举的数 $i$ 是否能与所判断的数 $n$ 整除，可以的话，它就不是质数是合数。

### 版本一

```c++
bool primes(int n){
    if(n<2)return false;
    for(int i = 2; i < n; i++)
        if(n%i==0)return false;
    return true;
}
```

很明显版本一的写法时间复杂度是 $O(n)$ 。这种写法简单直白，但过于无脑。

我们只要稍微简单思考一下，就不难发现对于每一个数 $n$ ，其实只需要从2 开始枚举到 $ sqrt(n)$ 即可，即时间复杂度 为 $O(\sqrt n)$ 。

### 版本二

```c++
bool primes(int n){
    if(n<2)return false;
    for(int i = 2; i <= n/i ; i++)
        if(n%i==0)return false;
    return true;
}
```

#### PS：一丢丢细节

对于 **版本二** 中的循环退出条件 $i<= n/i$ 有一丢丢需要注意的细节：

- 需要写成 $i<=n/i$ 而不是 $i<n/i$ 。( $i^2 == n$ 的情况)
- 不推荐写成 $i<=sqrt(n)$ ，因为多次函数调用对会拖时间复杂度。
- 不推荐写成  $ i * i <= n$ 的形式。因为当 $i = sqrt(Max(int))$ 时，数据会溢出。

## 分解质因数

我们先来看看模板题的问法：[867. 分解质因数](https://www.acwing.com/problem/content/869/)

### 描述

给定 $n$ 个正整数 $a_i$，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。

### 分析

对于这个问题，一种很直白的方式可以立马涌上心头：

1. 从小到大枚举所有可能数 $i$
2. 对于每个可能的 $i$ ，先判断是否是 $n$ 的因数，再判断是否是质数。条件都成立才进行操作。

### 版本一

```c++
void divide(int n)
{
    for (int i = 2; i <= n ; i ++ )
        if (  (n % i == 0) && is_prime(i) )
        {
            int s = 0;
            while (n % i == 0) n /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    cout << endl;
}
```

简单分析可知，该算法的时间复杂度为  $O(n*\sqrt{n} )$ 。这复杂度对于分解质因数这种基本常见操作来说，还是有点难以接受的。

这里，我们需要知道一个常用的定理——**算术基本定理**（也叫**唯一分解定理**）。

### 算术基本定理

任何一个大于1的[自然数](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E8%87%AA%E7%84%B6%E6%95%B0/385394)N,如果N不为**质数**，那么N可以**唯一**分解成有限个质数的乘积。

表达式形如：
$$
N=P_{1}^{a_{1}}P_{2}^{a_{2}}P_{3}^{a_{3}}...P_{n}^{a_{n}}
$$


至于，这个定理的证明过程，感兴趣的朋友可以参考[这篇文章](https://zhuanlan.zhihu.com/p/345488859)。考虑到篇幅原因，就不展开叙述了。

有了算法基本定理后，我们可以发现 $is\_prime(i)$ 显得有些多于，因为每次枚举到的n的因数必然是质数。所以可以得出如下代码：

### 版本二

```c++
void divide(int n)
{
    for (int i = 2; i <= n ; i ++ )
        if (n % i == 0)
        {
            int s = 0;//s 为 质因数的指数
            while (n % i == 0) n /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    cout << endl;
}
```



同试除法判质数一样，我们最多只需要枚举到 $\sqrt n$ 就可以了。不过需要稍微注意一下的是，对于质数，存在唯一一个大于 $\sqrt n$ 的因数，即它自己本身，所以我们需要做一下特判，代码如下：

### 版本三

```c++
void divide(int x)
{
    for (int i = 2; i <= n / i; i ++ )
        if (n % i == 0)
        {
            int s = 0;
            while (n % i == 0) n /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (n > 1) cout << n << ' ' << 1 << endl;	//特殊处理
    cout << endl;
}
```

---

## 质数筛法

ok，上面我们解决了**判断一个数是否是质数** 的问题，以及解决这个问题所用到的试除法对于求分解质因数的一丢丢拓展。下面我们来讨论下， **短时间内频繁使用多个不同的质数** 的问题。

直观感受是，每次要用的时候直接调用 $is\_prime()$ 即可。可如果短时间内需要调用 $n$ 次的话时间复杂度就是 $O(n\sqrt n)$ ，这个复杂度多多少少差点意思。

一个直观的例子是，OJ 上的评测机 1s 大概可以跑 $10^8$ 数量级，程序常数小一点的话最多跑到 $10^9$ 。那么对于短时间内需要求 $10^6$ 量级 次的质数时，就肯定超时了。

既然每次需要用的时候，才去 "**动手验证**" 这个数是否是质数太慢的话，我们就用空间换时间吧！ **筛选出自然数N以内所有的素数，用这些素数创建一张素数表 primes[n]**，每次需要用质数时，直接查表就可以实现单次查询 $O(1)$ 的复杂度。

那么这个问题就转换为： **如何用尽可能低的时间复杂度创建一张素数表 primes[n] ？** 

### 普通筛法

**模板题**：[acwing 868. 筛质数](https://www.acwing.com/problem/content/870/)

#### 原理

继续从空间换时间的角度思考，我们可以创建一个标记数组 $st[N]$ ，用以表示 [1,N-1] 中哪些数是质数。

然后一种比较朴素的筛选素数的方法就不难得出了，流程如下：

1. 从2开始枚举，如果当前枚举到的数 $st[i]$ 没有被标记，就把该数放入素数表。
2. 对于枚举到的每个数，把它们在 $N$ 以内的所有倍数都标记为非素数。

![get_primes_1.1.drawio](https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/mgs/Blog/Algorithms/Number/get_primes_1.1.drawio.png)

枚举过程的简略过程如上图。

#### 代码实现

```c++
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i){
            st[j] = true;
        }
    }
}
```

#### 复杂度分析

对于枚举到的每个数 $i$ ，我们都需要标记  $N/i$ 次。所以记：
$$
f(N)= N(1/2 + 1/3+ 1/4 +...+ 1/N)
$$
其中，
$$
\lim\limits_{n \to \infty} (1/2 + 1/3+ 1/4 +...+ 1/N) = lnN+C
$$
这里的 $C$ 为欧拉常数。

即：
$$
\begin{eqnarray}
F(N) &=& N*f(N)\\
	 &=& NlnN + N*c		\\
\end{eqnarray}
$$
所以时间复杂度为  $O(F(N)) = O(NlogN)$ 。

显然，如果短时间内需要频繁判断一个数是否是质数的话，这种方式比试除法的 $O(n\sqrt n)$ 快了一个数量级。但这还不够！！！

### 埃氏筛法

![get_primes_1.1.drawio](https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/mgs/Blog/Algorithms/Number/get_primes_1.1.drawio.png)

上图是我偷懒的产物，但也不难看出，如果对于枚举到的每个数 $i$ 都需要把他们的倍数做标记的话，会有大量的重复标记动作。

而根据**算术基本定理**：
$$
N=P_{1}^{a_{1}}P_{2}^{a_{2}}P_{3}^{a_{3}}...P_{n}^{a_{n}}
$$
可知，任何大于1的自然数，都可由若干个质数相乘而得，所以我们每次其实只需要枚举质数就可以了，不用所有数都枚举。

#### 代码实现

```c++
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i){
            st[j] = true;
        }
    }
}
```

因为这是n年以前的古希腊，一位叫 **埃拉托斯特尼** 的老哥最先想出来的，所以这算法也叫埃式筛法。

#### 复杂度分析

由 [素数定理](https://zh.m.wikipedia.org/zh-hans/%E8%B3%AA%E6%95%B8%E5%AE%9A%E7%90%86) 知，实数 $N$ 以内的素数 $π(N)≈ N/lnN$  个，所以粗略估算的话比原来少枚举了 $lnN$ 倍 个数，即粗略估算的话，时间复杂度可以看成是 :
$$
O(NlogN / logN) = O(N)
$$
但实际上埃式算法的精确时间复杂度是  $O(NloglogN) $ ，至于这玩意儿是怎么来的，不重要。~~(本人数学比较渣，没搞懂)~~

以下是朴素筛法和简单优化后的埃式筛法，在 $n≤10^6$ 量级下的测试结果。

（第一条为朴素筛法，第二条为埃式筛法）

![get_primes1_vs_2](https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/mgs/Blog/Algorithms/Number/get_primes1_vs_2.png)

可以看出，优化效果还是比较明显的。

### 线性筛法

#### 原理推导

![get_primes_1.1.drawio](https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/mgs/Blog/Algorithms/Number/get_primes_1.1.drawio.png)

还是这图。进一步的，我们可以发现，即使只是把所以质数的倍数筛掉，还是有不少重复标记的动作发生。

那么，有没有可能存在一种只用枚举一遍，且不重不漏的筛选方法，可以把 $N$ 以内所有的非素数标记出来呢？

来，让我们继续再来瞅瞅算术基本定理：
$$
N=P_{1}^{a_{1}}P_{2}^{a_{2}}P_{3}^{a_{3}}...P_{n}^{a_{n}}
$$


可以发现，对于一个合数 $N$ ，我们只需要找到它的最小质因数 $P_1$ ，就可以写成如下形式：
$$
N = A * P_1
$$
看到这里，有的朋友可能会吐槽：“你这不就是想说一个合数可以通过一个质数的倍数筛掉嘛，这和埃式筛法没啥不同吧？”

哎，非也，上式想表达的是：合数只被它的最小质因数筛掉即可。

那么现在问题就转换为：

1. 如何判断枚举到的质数是哪些数的最小质因数？
2. 如何做到同一个作为倍数 常数$A$ 为所有的质数服务，而不是每找到一个最小质因数后常数$A%$ 都从 2开始枚举？

在回答这两个问题之前，先回顾一下我们现在的初衷。

在前面，我们是对埃式筛法中，虽然只筛了质数的倍数，但还是带来了重复标记的操作这个行为不满，从而思考能否进一步优化算法。

但是各位大哥，埃式筛法的时间复杂度已经是 $O(NloglogN) $ ，粗略估算的话都可以直接当 $O(N)$ 的算法看待了。如果还想进一步优化的话，只能是优化到真正的 $O(N) $了。而想要筛出一张素数表，你总得从小到大把所有数都**过一遍**才能筛出哪些是素数吧？所以优化的极限也只能到 $O(N) $ 了。

哎，OK，回顾完毕。现在再来看看问题，结合已知条件，可以得出以下要素：

1. 所有数得从小到大过一遍。
2. 常数$A%$ 不能每次从小开始枚举。(哎，或许 从小到大遍历的每一个数都可以当 $A%$ 使？)
3. 枚举到没被标记过的数都是素数。(由算术基本定理易知)
4. 合数只需被最小质因数标记即可。

哎，好像可以召唤神龙了？

由上面的要素 $1、2、3$ 可得：
$$
i≥primes[j]  \ \ \ \ \ \ \ \ \ \ \ \ \ \ 要素5
$$
其中，$i$ 为当前枚举到的数，$j$ 为素数表的下标，$primes[j]$ 为当前已筛选出的素数列表的所有数。

所以，由要素 $4$ 和刚推出的要素 $5$ 为依据，我们可以做两件事：

- 以 $i$ 为倍数，对所有 $primes[j]*i$ 进行标记。
- 遍历 $primes[j]$ 的过程中判断 $primes[j]$ 是否是 $i$ 的最小质因数，如果是的话，$primes[j]$ 就没有继续遍历下去的价值。

OK，经过以上辣么长的思维推导，我们可以得出以下代码：

#### 代码实现

```c++
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; j<cnt && primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```







# 约数

- 试除法求约数
- 约数个数 & 约数之和

- 求所有约数
- 约2数个数
- 约数之和
- 最大公约数



int范围内，约数最多的一个数大概有1500-1600个





## 相关习题

- UVa1644 素数间隔
- UVa1213 不同素数之和
- UVa1210 连续素数之和
- UVa10539 几乎是素数
- UVa10622 完全**P**次方数
- UVa294 约数
- AcWing 1292. 哥德巴赫猜想
- AcWing 1293. 夏洛克和他的女朋友
- AcWing 196. 质数距离
- AcWing 197. 阶乘分解
- AcWing 1291. 轻拍牛头
- AcWing 1294. 樱花
- AcWing 198. 反素数
- AcWing 200. Hankson的趣味题
- [SDOI2008 仪仗队](https://www.luogu.com.cn/problem/P2158)
- [SP526 DIV - Divisors](https://www.luogu.com.cn/problem/SP526)
- [P4626 一道水题 II](https://www.luogu.com.cn/problem/P4626)

