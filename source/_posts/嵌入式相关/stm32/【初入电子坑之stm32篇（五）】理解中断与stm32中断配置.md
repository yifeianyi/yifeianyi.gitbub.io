---
title: 【初入电子坑之stm32篇（五）】理解中断与stm32中断配置
mathjax: true
date: 2021-01-19 20:30:15
tags: stm32
categories: 电子
---

## 前言

> 按照个人习惯，本文将从“这是啥？”“为啥需要它？”“如何操作？”三个角度展开讨论分析。

<!--more-->

## 目录

- 中断简介
- 中断理解
- stm32中的中断设置
  - NVIC
  - stm32中断配置
- 总结

## 中断简介

中断，即机器运行过程中出现某些意外情况，需机器停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。

## 理解中断

想象一下这么一个场景：

你在认真的敲代码，你妈喊你出房间去客厅恰饭，并且以不出来就拔网线为威胁。这时候你能怎么办？只能乖乖保存好文档，然后去恰饭，恰完再回来打开之前的文件继续敲咯。

我们分析一下上述的场景：

- 正在敲代码——**当前执行的事件**
- 你妈喊你吃饭——**中断源**
- 你听到你妈喊你吃饭——**接受到中断请求**
- 威胁你——**事件优先级别高**
- 保存已经写好部分——**保存现场**（中断响应）
- 去恰饭——**执行中断事件**
- 恰饭回房间——**中断返回**
- 打开文件继续敲码——**恢复现场**

![中断简介](中断简介.jpg)

对于机器来说也是一样的。无论是内核出现问题（异常），还是因为存在其他比当前正在执行的程序的优先级更高的事件发生（外部中断），都会打断当前运行的程序，去处理更加重要的事。

毕竟，机器的运算速度再快，处理事件也有先后之分不是？

接下来，让我们再次回到刚刚那个场景，考虑下面两种情况：

1、当正在吃饭的时候，你忽然想去WC解决下个人问题。这时你会停止恰饭这个动作，然后去WC解决完再回来继续吃饭。吃完饭才会继续

2、当正在吃饭的时候，你收到快递小哥的短信，告诉你丰巢的验证码可以去取的时候。你肯定会先恰完饭，然后去取完快递之后（也可能先在那放着先不取）再回房间敲代码。

对于情况1而言，为了避免某些比较尴尬的事情发生，先去WC再回来吃饭几乎是必然选择。因为它比吃饭紧急。而对于情况2取快递，相对来说没那么急迫的需求，所以一般而言我们都会先吃完饭，再去拿快递，最后再回房间敲代码。

当然如果要敲的代码比较着急，那么拿快递这件事自然就得等到我们敲完代码先啦。

从上面两个常见的场景中，我们很容易发现中断是可以嵌套的，且它有一定的优先级概念。

很显然，我们的日常生活中也会有许多中断事件。我们人脑是怎么处理它们的？认真思考下下不难发现，其实对于很多事件，我们早就给它们分门别类且定义了优先级。而定义这些事件的类别、优先级，并严格执行的就是我们的大脑。

对于单片机 or CPU来说也一样。当中断事件很少的时候，不需要分门别类的整理，直接比较比较判断优先级就可以了。

而对于中断事件较多的复杂系统，对于事件的分组和优先级设置也就成了刚需。

下面我们以stm32f10x的中断系统为例，展开学习。

## stm32中的中断设置

我们知道，stm32用的是cortex-M3内核。

而CM3内核支持256个中断，256级可编程设置（即优先级设置），其中：

- 内核中断16个
- 外设中断240个

但stm32并没有把CM3内核的设置全部用上。
它仅有84个中断，16级可编程设置，其中：

- 内核中断16个
- 外设中断68个

且以上配置属于stm32中的顶配，具体到 f103系列只有：

- 内核中断16个
- 外设中断44个

小结下以上的数据，可以发现，实际中断事件的多少取决于芯片的定位。高端的，即外设多的，芯片中断必然多，反之必然少。

### NVIC

而要处理那么多的中断事件，CM3内核给出的解决方案是——用NVIC (Nested Vectored Interrupt Controller)嵌套向量中断控制器控制。

NVIC首先定义了一段地址区域（一般以0地址开始）用于存放中断事件服务函数的地址。定义的这段地址就称为**中断向量表**。

![中断向表表1](中断向表表1.png)

![中断向量表2](中断向量表2.png)

以上是从《stm32f10x 中文参考手册》中截来。

可以看到它一个地址对应着一个中断事件，其中灰色部分是内核相关的中断的位置。每当一条指令执行完之后，系统都会检查一遍看看有没有中断事件发生。如果有的话，就会在中断向量表中找到对应的中断事件，执行中断事件所在地址指向的函数（即中断函数）。

也就是因为中断事件所在的地址存的是一个地址，它指向的是该中断对应发生的事件（函数）。所以其实中断向量表这个名字起得很符合它的实际含义——**表里的是一个个有指向的值**。

至于定义这些中断事件的优先级和它们具体是干嘛的，NVIC把设置的权利交给了开发者，它只给了可以完成相关操作的寄存器组。

![NVIC结构体](NVIC结构体.png)

从固件库头文件：core_cm3.h中，我们可以找到以上NVIC的寄存器组映射。

其中如果我们使用寄存器编程的话，最关心的寄存器一般是：

- ISER：Interrupt Set Enable Register，中断使能设置寄存器
- ICER：Interrupt Clear Enable Register，中断使能清除寄存器
- IP：Interrupt Priority Register，中断优先级寄存器

在这里面，中断优先级寄存器是需要我们着重研究的。有意思的是，固件库命名的时候对于该寄存器的简写直接只用IP，而不是IPR，害我一度怀疑这两是不是同一个东西。直到我去查了手册才验明了“真身”。

#### IPR中断优先级寄存器

原CM3设计中，NVIC_IPRx用于配置外部中断的优先级。IPR宽度为8bit，理论上可以配置的优先级为0~255，数值越小优先级越高。但和大多数CM3芯片都会精简设计一样，stm32做了精简设计，只使用高4bit。也就是说，实际上stm32允许配置的优先级只有16级。

![IPR寄存器结构](IPR寄存器结构.png)

#### 抢占优先级与子优先级

而为了中断的机能可以变得更加可控，CM3把优先级划分成了抢占优先级和子优先级（又叫响应优先级）。即，对于同一个中断事件，他有抢占优先级和子优先级两个优先级。

只有当抢占优先级相同的时候，子优先级才会发挥左右。若子优先级也相同，就去比较两个中间的硬件中断编号。

而 抢占优先级 与 子优先级 还是有些许差别的：

- 抢占优先级：无关中断产生的先后，只比较优先级的高低。优先级高的中断信号即使比中断优先级低的中断信号后到，也可以直接中断优先级低的事件**直接抢占系统资源**。
- 子优先级：当两个中断信号有相同的抢占优先级，分两种情况考虑：
  - 两个信号同时到达，子优先级高的中断先响应。
  - 子优先级低的中断事件正在发生，子优先级高的中断信号刚到时，需要等到当前中断完成后，在执行玩到的中断信号。

#### 中断分组

从前面的讨论中我们可以知道，由于中断事件众多，光有优先级是不够的，还需要对这些事件进行分组管理。

这个分组管理的设置由内核外设SCB_AIRCR（应用程序中断及复位控制寄存器）的prigroup[10:8]控制。

![SCB_AIRCR](SCB_AIRCR.png)

因为它通过3个bit控制，所以理论上可以分成8组（0~7组），其中每组可设置的抢占优先级和子优先级的位数是不同的。

![CM3中断分组完整图](CM3中断分组完整图.png)



 如上图，可以看到它随着组号的增大，抢占优先级可设置的位越少，子优先级越多。

要深究它的分组思想的话，其实也不难，因为它很像国家不同层级的部门。思考下这么一个问题（类比下），层级越高的部门里，级别高的官员比较多（抢占优先级位数多），“弟弟”比较少（子优先级位数少）是一个相对必然的现象，这也比较符合一个系统的运作规律。

上面这种分组是针对IPR里8bits都用上的情况设计的。而我们知道，stm32的NVIC是CM3的NVIC的子集，只用了高4bits，所以分组自然而然就少了。

![stm32中断分组完整图](stm32中断分组完整图.png)



有了以上的原理性认知，我们终于进入到轻松愉快的编程配置环节~~~

#### 配置要点

根据前面叙述的内容，辅以一些额外资料（诸如各种官方文档），我们可以得出以下流程：

- 使能某个的中断
- 初始化NVIC_InitTypeDef 结构体
  - 设置中断源
  - 设置抢占优先级和子优先级
  - 配置中断使能/失能
- 编写中断服务函数（就是这个中断发生后，告诉机器去干嘛）

## 配置实例——EXTI

---

未完待续~~~