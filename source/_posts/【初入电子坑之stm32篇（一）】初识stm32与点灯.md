---
title: 【初入电子坑之stm32篇（一）】初识stm32与点灯
mathjax: true
date: 2020-12-26 13:49:19
tags: [stm32]
categories: 电子
---

## 前言

> 一下为本人基于野火stm32F103EVT6开发板学习stm32的学习笔记。

<!--more-->

## 导图概览

![初识stm32概览](初识stm32概览.png)

## 初识32

### 1、下载方式

把单片机耍起来，除了要写程序外，当然还得把程序下载到单片机的上啦！而stm32一般支持以下两种下载方式：

- 仿真器下载
- ISP下载

曾经玩过简单玩过一下下51和arduino。这两个硬件平台玩的时候都对下载方式进行了一定的简化，所以直到现在我才知道下载方式也是有讲究的orz。

#### 仿真器下载

仿真器下载就是，下载程序的时候，在片外连接一个叫仿真器的东西。连上这个东西之后可以实时烧录程序观察板子的现象，无需按reset按键，并可以单步跟踪调试观察实时现象。

虽然目前木有入手仿真器，不过以前简单玩过的板子内集成了类似的功能，所以也算体验过了。

#### ISP下载

全称：In-System Programmability，即：在系统可编程。

一开始我看到这名字的时候有点蒙蔽，ISP下载？啥玩意儿，网络运营商下载？查过资料才知道，在很久很久之前~~~老前辈们烧录程序时居然还要把芯片取下来，拿到专门烧录的程序机器上烧录程序，然后再插会电路板上，十分麻烦。而ISP下载，就是现在习以为常的在板上插根线，直接连接电脑烧录程序的方式。

在目前“以实现功能为主，不深究具体实现。”的学习思想指导下，对于这东西，没啥需要注意的。了解一下，表达下对前辈们的敬意即可。

### 2、芯片选型

即使是同一款芯片,也有很多不同的型号。它们的差别体现在cpu位数、引脚数、晶振频率、flash、可用外设的差别上，虽然对于个人学习实验来说只要功能相对够齐全一般都没啥问题。但在DIY项目、工业生产上，每bit都要尽量抠着用。（多一毛钱，乘于1w、100w都是好多好多钱啊！！！）

所以简单了解下，还是很有必要的。

#### stm32命名规则

![stm32命名规则](stm32命名规则.png)

7部分：

- STM32：ST公司生产的Cortex-M内核的32位微控制器
- F：芯片的基础型子系列。还有其他的诸如：S标准型、L超低功耗等。
- 103：跟上面类似。
- V：引脚数代号，V表示100引脚。
- E：flash大小代号，E表示512KB。
- T：芯片封装种类。
- 6：芯片适应温度等级。

以上信息做到大概了解即可。有具体需求时，看官方的选型手册即可。

### 3、系统结构

![stm32芯片架构](stm32芯片架构.png)

上图为stm32的芯片架构简图。其中大概可以分由ARM公司设计的Cortex-M3内核，和由ST公司以Cortex-M3内核为基础设计的辅助结构。

而我们可以操作的部分就是外设的寄存器，通过操作外设寄存器的值，从而控制芯片I/O引脚的输出来完成我们需要的操作。

关于寄存器的相关知识，可我的汇编笔记参考：

{% post_link 汇编语言(一)基础知识与寄存器 汇编语言(一)基础知识与寄存器 %}

（还没填完坑。。。）



![stm32系统框图](stm32系统框图.png)

上图为stm32的结构框图，其中AHB系统总线连接着外设。换句话说，我们可以通过AHB总线，进行最大限度的自由发挥，是可以为所欲为的地方。

AHB通过桥接的方式分出APB1、APB2两条外设总线，它们分别挂载着一些外设，其中APB1的访问速率比APB2慢一倍。

通过ST公司的官方手册，我们可以找到AHB的存储器映射地址，如下图：

![AHB地址映射](AHB地址映射.png)

然后，理论上我们就可以以此为基础，设计程序了。

## 入门运用

### 0、启动文件

其实在51、arduino中也有这个东西。不过在创建工程的时候，软件给我们自动添加了。

而stm32比较牛逼......型号比较多，使用范围比较大。官方根据具体不同型号的需求给出了多个不同启动文件，所以这里需要我们手动添加。

在这里，我们只需要对启动文件有个初步认识即可。它的作用如下：

- 使用汇编指令对内核进行一些必要的初始化。
- 利用汇编指令在stm32芯片上搭建了一个c语言的运行环境。

### 1、GPIO

#### 简介

**GPIO**（英语：General-purpose input/output），功能类似8051的P0—P3。不同的是，这哥们比较高级，下面放张它的结构图，让大家感受下它的“高级”：

![GPIO端口结构](GPIO端口结构.png)

在51里，P0——P3我们可以直接修改它们对应的输出数据寄存器的值从而控制I/O口的输出。但从上图我们可以看到，对于GPIO我们需要操作多个寄存器，才可以在修改输出数据寄存器ODR内的数据。

当然啦，既然操作相对辣么繁琐，必然有它的意义所在——这哥们有8个输入/输出模式：

##### 输入：

- 输入浮空
- 输入上拉
- 输入下拉
- 模拟输入

##### 输出：

- 开漏输出
- 推挽输出
- 开漏复用功能
- 推挽复用功能

我曾经很舍本逐末的探究了上面几种输入输出模式背后的原理，然鹅。。。发现由于认知层面的缺失，即使勉强研究明白了几分，也没什么卵用。。。

所以还是先把它用起来吧，其他的以后再说。。。

#### 控制流程

想要令GPIO的I/O口输入/输出值，要进行以下流程：

1. 开启对应端口的时钟使能端（为了节省功耗，外设的使能默认关闭）。
2. 选择引脚，并配置对应的IO模式、若是输出模式选择输出速率。
3. 控制端口寄存器CRL/CRH清零
4. 设置引脚(即：数据输出/输入寄存器ODR)的值。

由以上对GPIO的认知，我们可以引申出两种在stm32上不同的编程方式：

- 基于寄存器编程
- 基于固件库编程

下面以点亮LED灯为例，进行分析。

### 2、基于寄存器编程

基于寄存器编程其实又可以叫**基于数据手册编程**，因为它很简单粗暴。

![](野火LED模块.png)

上面是野火指南者开发板的LED原理图。可以看到这是个三原色LED灯，通过PB1、PB0、PB5端口输出低电平就可以让LED发出对应的灯光颜色。

根据上一小节中，我们分析控制GPIO端口的流程。我们先从官方的数据手册分别找出对应的寄存器地址。

![RCC基地址](RCC基地址.png)

![APB2使能控制地址](APB2使能控制地址.png)

![GPIOB基地址](GPIOB基地址.png)

从而得出Level1版的点灯程序：

#### Level_1：

##### 宏定义：

~~~c
	typedef unsigned int uint;
	#define RCC_APB2ENR *(uint*)0x40021018
	#define GPIOB_CRL  *(uint*)0x40010C00
	#define GPIOB_ODR *(uint*)0x40010C0C
~~~

##### 核心操作：

~~~c
	/***********初始化*************/
	/*
			1、开启GPIO端口时钟 
			2、端口清零
			3、配置输入/输出模式、输出速率
	*/
	//开启端口时钟
	RCC_APB2ENR |= (1<<3);
	
	//清零控制PB0的端口位
	GPIOB_CRL &= ~( 0x0f );
	//配置PB0为通用推挽输出，速度为10M
	GPIOB_CRL |= 1;
	/*********控制引脚电平输出*********/
	//PB0输出低电平
	GPIOB_ODR &= ~(1);
~~~

上面这段代码值得说道的是，使用无符号整形指针对十六位地址进行强制类型转换，使一个十六进制数变成了地址标号。然后就顺理成章的在它前面加各“*”解引用，对那块十六进制数表示的地址赋值。手段很妙，学到了，orz。。。

```c
(uint*)0x40010C0C;		//十六进制数地址化
*(uint*)0x40010C0C;		//解引用
```

但以上做法过于简单粗暴，即使以基于纯寄存器开发角度，代码的维护性也过于的差。所以引申出level2版，基于基址+偏址的宏定义版本。

#### Level_2:

##### 宏定义：

```c
ypedef unsigned int uint;

//外设宏定义 peripheral
#define PERIPH_BASE  			(uint)0x40000000
#define APB2PERIPH_BASE  		PERIPH_BASE+(0x10000)
#define AHBPERIPH_BASE  		PERIPH_BASE+(0x20000)	//时钟控制

//定义时钟复位寄存器和GPIOB的基地址
#define RCC_BASE 		(AHBPERIPH_BASE+0X1000)
#define GPIOB_BASE		(APB2PERIPH_BASE + 0X0C00)

#define RCC_APB2ENR		*(uint*)(RCC_BASE + 0X18)	//apb2总线使能地址

#define GPIO_CRL		*(uint*)(GPIOB_BASE + 0X00)
#define	GPIO_CRH		*(uint*)(GPIOB_BASE + 0X04)
#define GPIO_ODR		*(uint*)(GPIOB_BASE + 0X0C)
```

***

未完待续~~~