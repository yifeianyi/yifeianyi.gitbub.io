---
title: 蓝桥杯 分巧克力
date: 2020-10-08 20:15:41
tags: [二分,蓝桥杯,算法]
categories: 题解
mathjax: true
---

[题目链接](https://www.acwing.com/problem/content/1229/)

#### 问题描述

儿童节那天有 K 位小朋友到小明家做客。

小明拿出了珍藏的巧克力招待小朋友们。

小明一共有 N 块巧克力，其中第 i 块是 H<sub>i</sub>×W<sub>i</sub> 的方格组成的长方形。

为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。

切出的巧克力需要满足：

1. 形状是正方形，边长是整数
2. 大小相同

例如一块 6×5 的巧克力可以切出 6 块 2×2 的巧克力或者 2 块 3×3 的巧克力。

当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？

<!--more-->

#### 输入格式

第一行包含两个整数 N 和 K。

以下 N 行每行包含两个整数H<sub>i</sub>和W<sub>i</sub> 。

输入保证每位小朋友至少能获得一块1×1 的巧克力。

#### 输出格式

输出切出的正方形巧克力最大可能的边长。

#### 数据范围

1 ≤ N,K ≤10<sup>5</sup>
1 ≤ H<sub>i</sub>,W<sub>i</sub> ≤ 10<sup>5</sup>

### 分析

这题好像还算挺裸的一道二分查找问题。因为题目要求分得的最大边长，但看完题目除了枚举试最大边长外并无他法。而**Max(N)=1e5**，纯暴力试错的最坏情况是O(n<sup>2</sup>)，明显不行。那么想到用二分就是比较顺其自然的事情了。

<img src="配图（1）.jpg" alt="配图（1）" style="zoom: 25%;" />

而很显然，当边长d越大，能得到的总和块数S就越少。设f(d)为边长为d时分得的块数，即有：
$$
if(f(mid) ≥ k)\quad L=mid\\
else \quad R=mid-1
$$

#### 代码

```c++
#include<iostream>
using namespace std;
const int N = 1e5+10;
int h[N],w[N];
int n,k; 
bool check(int x){
	int ans = 0;
	for(int i=0;i<n;i++){
		if(x>w[i]||x>h[i])continue;
		ans+= (w[i]/x) * (h[i]/x);
		if(ans>=k)return true;
	}
	return false;
}
int main(){
	cin>>n>>k;
	for(int i=0;i<n;i++)cin>>h[i]>>w[i];
	
	int l=1,r=1e5;
	int mid;
	while(l<r){
		mid = l+r+1 >> 1;
		if(check(mid))l=mid;
		else r=mid-1;
	}
	cout<<l<<endl;
	return 0;
}
```





