<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux 监控工具</title>
    <url>/2021/08/23/Linux/Base/Linux-%E7%9B%91%E6%B5%8B%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="概要">概要</h2>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/Linux/%E7%9B%91%E6%B5%8B%E5%B7%A5%E5%85%B7%E5%AF%BC%E5%9B%BE_1.png" alt="监测工具导图"></p>
<a id="more"></a>
<h2 id="nethogs">NetHogs</h2>
<h3 id="作用">作用</h3>
<p>一个开源的命令行工具（类似于Linux的top命令），用来按进程或程序<strong>实时统计</strong>网络带宽使用率。</p>
<h3 id="使用">使用</h3>
<ul>
<li>默认情况</li>
<li>交互式命令</li>
<li>命令行参数</li>
</ul>
<h4 id="默认情况">默认情况</h4>
<p>在命令行中输入nethogs即可进入该界面。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/Linux/NetHogsUI.png" alt="NetHogs界面"></p>
<p>从第一栏中可以看到，每列的内容分别是：</p>
<ul>
<li>PID：进程ID</li>
<li>User：进程所属用户</li>
<li>Program：程序在地址所在（如：对应的本地地址、ip地址端口号）</li>
<li>Dev：如果进程属于某个设备，如：网卡eth0则会显示出来，否则不显示</li>
<li>Sent、Received：发送、接受的流量的速率</li>
</ul>
<h4 id="交互式命令">交互式命令</h4>
<ul>
<li>m: 按 m键，切换单位或显示占用速度；切换顺序是（KB/sec，KB，B，MB）</li>
<li>r : 按 r 键，按接收流量排序</li>
<li>s : 按 s 键 ，按发送流量排序</li>
<li>q : 按 q 键退出</li>
</ul>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/Linux/NetHogsTest_1.png" alt="NetHogsTest_1"></p>
<h4 id="命令行参数">命令行参数</h4>
<p>-h :显示可用命令的用法</p>
<p>-V :打印版本信息</p>
<p>-d :延迟刷新率(延迟刷新时间)，单位是秒，默认为每秒刷新一次</p>
<p>-v :选择视图模式</p>
<p>-p :混合模式下嗅探（不推荐）</p>
<p>-t :跟踪模式</p>
<h2 id="htop">htop</h2>
<h3 id="作用">作用</h3>
<p><strong>交互式</strong>进程管理器</p>
<h3 id="界面">界面</h3>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/Linux/htopUI.png" alt="htopUI"></p>
<h4 id="上半区">上半区</h4>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/Linux/htopUI_1.png" alt="htopUI_1"></p>
<h4 id="下半区">下半区</h4>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/Linux/htopUI_2.png" alt="htopUI_2"></p>
<ul>
<li>PRI：进程的优先级</li>
<li>NI：进程的优先级别值，默认的为0，可以进行调整</li>
<li>VIRT：进程占用的虚拟内存值</li>
<li>RES：进程占用的物理内存值</li>
<li>SHR：进程占用的共享内存值</li>
<li>S：进程的运行状况，R表示正在运行、S表示休眠，等待唤醒、Z表示僵死状态</li>
<li>CPU%：该进程占用的CPU使用率</li>
<li>MEM%：该进程占用的物理内存和总内存的百分比</li>
<li>TIME+：该进程启动后占用的总的CPU时间</li>
<li>COMMAND：进程启动的启动命令名称</li>
</ul>
<h4 id="功能栏">功能栏</h4>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/Linux/htopUI_3.png" alt="image-20210821212336575"></p>
<p>根据需求，用到时再探索</p>
<h2 id="nmon">nmon</h2>
<h3 id="作用">作用</h3>
<p>它能在系统运行过程中实时地捕捉系统资源的使用情况，记录的信息比较全面，</p>
<p>并且能输出结果到文件中，然后通过nmon_analyzer工具产生数据文件与图形化结果。</p>
<h3 id="界面">界面</h3>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/Linux/nmonUI.png" alt="nmonUI"></p>
<p>通过初始界面显示的命令，如下图般的界面（使用了 C、c、n 三个指令）：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/Linux/nmonUItest_1.png" alt="nmonUItest_1"></p>
<p>可以看到，各项指标数据都很详细，具体使用时可以用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmon -h</span><br></pre></td></tr></table></figure>
<p>查看更多操作方式。</p>
<h2 id="dstat">dstat</h2>
<h3 id="作用">作用</h3>
<p>多功能系统资源统计生成工具（ versatile tool for generating system resource statistics），可以实时地看到所有系统资源。</p>
<h3 id="界面">界面</h3>
<p>默认显示内容：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/Linux/dstatUI.png" alt="dstatUI"></p>
<p>从蓝色虚线看，分成了以下几个部分：</p>
<ul>
<li>–total-cpu-usage–：CPU使用率</li>
<li>usr：用户空间的程序所占百分比；</li>
<li>sys：系统空间程序所占百分比；</li>
<li>idel：空闲百分比；</li>
<li>wai：等待磁盘I/O所消耗的百分比；</li>
<li>hiq：硬中断次数；</li>
<li>siq：软中断次数；</li>
<li>-dsk/total-：磁盘统计
<ul>
<li>read：读总数</li>
<li>writ：写总数</li>
</ul>
</li>
<li>-net/total- ：网络统计
<ul>
<li>recv：网络收包总数</li>
<li>send：网络发包总数</li>
</ul>
</li>
<li>–paging–： 内存分页统计
<ul>
<li>in： pagein（换入）</li>
<li>out：page out（换出）</li>
</ul>
</li>
<li>–system–：系统信息
<ul>
<li>int：中断次数</li>
<li>csw：上下文切换</li>
</ul>
</li>
</ul>
<h3 id="常用指令">常用指令</h3>
<ul>
<li>监控CPU\MEN： dstat --top-mem --top-io --top-cpu</li>
<li>常用常规监控：dstat -cmsdnl -D sda1 -N lo,ens33 100 5</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>基础操作</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>vim入门</title>
    <url>/2021/05/19/Linux/Base/vim%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>vim这款文本编辑器很强大，但由于它的模式多样、指令繁多，容易让初学者感到入门，畏惧不前。而由于本人近期学习安排中也需要用到vim（避无可避的程度），无奈之下只能试着硬上了，在这个过程中无意想通了正确的学习姿势，以下是个人的思考笔记。</p>
</blockquote>
<a id="more"></a>
<h2 id="本文大纲">本文大纲</h2>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/image-20210519200921571.png" alt="image-20210519200921571"></p>
<h2 id="理清问题">理清问题</h2>
<p>通过的思考，我发现vim之所以难学，有这么几个原因：</p>
<ol>
<li>模式多。</li>
<li>各模式的命令不少。</li>
<li>网上搜到的教程几乎都是指令的堆砌，对初学者不太友好。</li>
</ol>
<p>基于以上原因，在没有一个清晰的学习思路指引下，很容易会陷入死记命令的泥潭中。而走出这个泥潭的的常见办法是——用大量实践堆砌熟练度，说白的就是熟能生巧。</p>
<p>而我是个很懒的人。。。我想偷懒，以最少的练习量、最少的时间，尽可能的提高使用vim的使用效率。于是乎，我问了自己这么个问题：</p>
<ul>
<li><strong>vim是什么？vim是一个文本编辑器啊。</strong></li>
</ul>
<p>是啊，vim是一个文本编辑器啊！那作为一个程序猿，为什么不从自己设计一个文本编辑器的去看待vim辣么多的内容呢？</p>
<h2 id="如何设计文本编辑器">如何设计文本编辑器</h2>
<p>这里讨论的如何设计文本编辑器，为从宏观上分析，文本编辑器需要实现怎样的具体功能的角度出发。</p>
<h3 id="gui与命令行">GUI与命令行</h3>
<p>让我们从刚接触计算机时，用的最简陋的文本编辑器——<strong>记事本</strong> 开始分析：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/image-20210519203037698.png" alt="image-20210519203037698"></p>
<p>作为一个普通的小白用户，关注的点只有两个：</p>
<ul>
<li>怎么编写文本？</li>
<li>写好的文本，怎么保存？</li>
<li>怎么退出？</li>
</ul>
<p>我们都知道，这几个需求的实现在图形界面上，可以由上图方框框出来的三部分组成：</p>
<ul>
<li>红色方框的编辑区</li>
<li>蓝色方框的功能区中“文件”项下的保存键</li>
<li>绿色方框的窗口控制键</li>
</ul>
<p>但记事本所处的环境是GUI图形界面，vim是在纯命令行界面作用的文本编辑器。它没有能清晰可视化的功能分区，只有一个近似与上图红色方框编辑区的黑框框。</p>
<p>我们需要用也只能用这个黑框框去实现上述我们提到的所有功能。</p>
<p>那么一个  <strong>可切换的双模式</strong> 结构想法就很自然而然的应运而生了。</p>
<h3 id="核心功能">核心功能</h3>
<h4 id="双模式切换">双模式切换</h4>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2.png" alt="模式切换"></p>
<p>我们可以设定刚进入编辑器时为 <strong>命令模式</strong>。这个模式只有三个功能：</p>
<ul>
<li>进入编辑模式</li>
<li>保存文档</li>
<li>退出文档</li>
</ul>
<p>编辑模式下只有两个功能：</p>
<ul>
<li>文本编辑</li>
<li>退回命令模式</li>
</ul>
<p>这样编辑器最核心的功能——<strong>编辑文档</strong>，就实现了。</p>
<h4 id="常见需求">常见需求</h4>
<p>在实现了上述核心功能之后，我们就该来聊聊用户体验问题了。一个东西能用跟一个好用是两回事不是嘛。</p>
<p>除了核心的编辑功能外，我们最常用的功能大概有以下几个：</p>
<ul>
<li>复制粘贴</li>
<li>关键字检索</li>
<li>关键字替换</li>
<li>。。。。</li>
</ul>
<p>很显然，这些功能可以全丢到命令模式，编辑模式下就跟图形界面一样，乖乖的负责文本编写就好了。</p>
<p>当然，还有个很重要的需求——减少双手离开主键盘区的频率，提高文本编辑速度！！！</p>
<p>完成这个需求也很简单，能让我们离开主键盘区，移到键盘其他区域的无非就辣么几件事：</p>
<ul>
<li>Home/End键</li>
<li>PageUp/PageDown键</li>
<li>最重要的方向键</li>
</ul>
<p>把以上功能全丢到命令模式就好了。有了这些认识，学起vim来就很轻松啦~</p>
<h2 id="vim入门">vim入门</h2>
<p>ok，基于以上整理的思路，下面随便在网上找一份vim教程学习，我选的是菜鸟的教程。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/vim%E6%A8%A1%E5%BC%8F%E5%9B%BE.png" alt="vim模式图"></p>
<p>首先是上面这图。我一看，不对劲，为啥两个模式能搞定的东西，vim得搞出3个模式出来？命令模式好理解，底线命令模式是啥玩意儿？瞅瞅资料先…</p>
<p>吼，本菜鸡查完资料回来了~</p>
<p>首先是输入模式和命令模式，这两哥们跟我们前面讨论的差不多，至于底线命令模式是干嘛用的，你们瞅瞅下面这图：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/image-20210519220940400.png" alt="image-20210519220940400"></p>
<p>从上面的信息可以得出结论，底线命令模式这大哥的功能是：</p>
<ul>
<li>文档具体储存、退出方式的处理</li>
<li>vim环境的变更</li>
</ul>
<p>而普通命令模式主要是文本处理的相关指令的集合。</p>
<p>ok，大轮廓搞定了，我们看看具体细节。</p>
<h3 id="核心功能">核心功能</h3>
<h4 id="模式切换">模式切换</h4>
<p>还是用图说话。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/vim%E6%A8%A1%E5%BC%8F%E5%9B%BE.png" alt="vim模式图"></p>
<p>从前面可以知道，从简单使用角度，我们关注的重点更多的是在<strong>命令模式</strong>和<strong>输入模式</strong>。</p>
<p>输入模式退回命令模式直接ESC即可，这个无需多说。</p>
<p>而命令模式进入输入模式有三种基本方式：i，a，o</p>
<h5 id="示例">示例</h5>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/image-20210519225922738.png" alt="image-20210519225922738"></p>
<ul>
<li>i：在当前光标前插入（以 ‘.’ 为当前光标所处位置 ）</li>
</ul>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/image-20210519230029146.png" alt="image-20210519230029146"></p>
<ul>
<li>a：在当前光标后插入（以 ‘.’ 为当前光标所处位置 ）</li>
</ul>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/image-20210519230129163.png" alt="image-20210519230129163"></p>
<ul>
<li>o：新插入一行</li>
</ul>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/image-20210519230313194.png" alt="image-20210519230313194"></p>
<p>进入编辑模式之后就可以愉快写东西了。</p>
<p>然后写好的，想退出的话，从就在命令模式用 ’ : '进入底线模式，简单常用的命令有：</p>
<ul>
<li>w：保存</li>
<li>q：退出</li>
<li>wq：保存退出</li>
</ul>
<p>吼了，看到这里最基本的操作相信都木有问题了，还想要更多更好的用户体验只需要按照前面提供的思路去查文档即可~</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>基础操作</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>【初入电子坑之stm32篇（六）】定时器基础与Systick</title>
    <url>/2021/04/24/Embedded/MCU/stm32/%E3%80%90%E5%88%9D%E5%85%A5%E7%94%B5%E5%AD%90%E5%9D%91%E4%B9%8Bstm32%E7%AF%87%EF%BC%88%E5%85%AD%EF%BC%89%E3%80%91%E5%AE%9A%E6%97%B6%E5%99%A8%E5%9F%BA%E7%A1%80%E4%B8%8ESystick/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>定时器，顾名思义是拿来定时的，但除了定时之外，我们还可以利用定时器的计数特性，演变出其他有意思的功能出来（诸如控制马达转速）。不过在这之前，我们还是先了解了解定时器的工作原理叭。</p>
</blockquote>
<a id="more"></a>
<h2 id="本文概览">本文概览</h2>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/image-20210424160856026.png" alt="image-20210424160856026"></p>
<h2 id="一-定时器基本概念">一、定时器基本概念</h2>
<h3 id="1-1-计数宽度">1.1、计数宽度</h3>
<p>这里指计数器的位数。如：CM3内核中Systick定时器的计数位有24位，即最大计数值为 2<sup>24</sup> -1= 16,777,215。我们就说Systick的计数宽度为24。</p>
<h3 id="1-2-工作模式">1.2、工作模式</h3>
<p>定时器是人设计，而设计是自由的。既然你规定了计数的数值范围，那么我们从0数到16,777,215，跟从16,777,215 数到 0 都是可以的不是嘛，所以这就引申出了工作模式的概念：</p>
<ul>
<li>向上计数：从0数到16,777,215</li>
<li>向下计数：从16,777,215 数到 0</li>
</ul>
<p>这两种模式，从本质上来说没有任何区别。不过某些定时器可能没有给与我们开发者辣么自由的操作空间，限定了只可以向上计数or只可以向下计数。</p>
<h3 id="1-3-计数周期">1.3、计数周期</h3>
<p>既然我们规定了计数的范围，那么从1计数到2，从2计数到3之间的时间周期是多少？我们如何实现计数周期的不变？</p>
<p>这个问题其实很简单。。。利用时钟啊！时钟的脉冲信号变化规律是很容易确定的。那么我们就可以直接使用时钟实现计数周期，即：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mrow><mi>C</mi><mi>N</mi><mi>T</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><msub><mi>f</mi><mrow><mi>C</mi><mi>l</mi><mi>k</mi><mi>S</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>c</mi><mi>e</mi></mrow></msub></mfrac><mspace width="2em"/></mrow><annotation encoding="application/x-tex">T_{CNT} =  \frac{1}{f_{ClkSource}}\qquad
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.20188em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:2em;"></span></span></span></span></span></p>
<h3 id="1-4-计数时长">1.4、计数时长</h3>
<p>啥？刚刚说完计数周期，你现在给我来个计数时长？啥玩意？</p>
<p>哦，这哥们是拿来中断用的。</p>
<p>我们一开始提到了计数宽度，它决定了我们可以取到的最大计数值。但它也只是决定了我们可以取到的最大计数值，实际计数值CNT(count的简写)是多少，这不还是由我们自己定的嘛。根据项目需求，你想取多少就多少。即：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mi>C</mi><mi>N</mi><mi>T</mi><mo>×</mo><msub><mi>T</mi><mrow><mi>C</mi><mi>N</mi><mi>T</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t = CNT ×T_{CNT}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>当向上计数or向下计数达到了CNT次后，计数就会溢出触发一次定时器中断。这个中断有什么用？别急，后面我们我讨论到它。</p>
<h3 id="1-5-重装载计数器">1.5、重装载计数器</h3>
<p>刚刚我们已经说了当向上计数or向下计数达到了CNT次，就会触发一次定时器中断。那么中断结束之后，计数器怎么继续计时？很简单，设计一个专门控制检测计数状态的模块，当每次计数值达到了我们指定的CNT后，就重置计时器，让它重新计数就OK了。</p>
<p>而这个重置操作，一般称为重装载计数器，我们可以通过操作相关寄存器去控制它。</p>
<h3 id="1-6-定时器简易模型">1.6、定时器简易模型</h3>
<p>根据以上信息，我们可以构筑出下图的定时器模型：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(1).jpg" alt="定时器简易模型"></p>
<h2 id="二-systick">二、Systick</h2>
<h3 id="2-1-简介">2.1、简介</h3>
<p>SysTick—系统定时器是属于 CM3 内核中的一个外设，内嵌在 NVIC 中。也常称为滴答定时器，因为它只要简单的计数功能。</p>
<p>系统定时器是一个 24bit 的向下递减的计数器(PS：这里只能向下计数)，计数器每计数一次的时间为 1/SYSCLK。</p>
<p>因为 SysTick 是属于 CM3 内核的外设，所以所有基于 CM3 内核的单片机都具有这个</p>
<p>系统定时器，使得软件在 CM3 单片机中可以很容易的移植。系统定时器一般用于操作系统，用于产生时基，维持操作系统的心跳。</p>
<p>（以上为本人从野火的资料中，截取修改而来。）</p>
<h3 id="2-2-systick的应用与配置流程">2.2、Systick的应用与配置流程</h3>
<h4 id="2-2-1-systick的寄存器组">2.2.1、Systick的寄存器组</h4>
<p>对于Systick而言，有4个寄存器控制它，分别是：</p>
<ul>
<li>CTRL  ：SysTick 控制及状态寄存器</li>
<li>LOAD ：SysTick 重装载数值寄存器</li>
<li>VAL    ：SysTick 当前数值寄存器</li>
<li>CALIB ：SysTick 校准数值寄存器</li>
</ul>
<p>有了上一节的内容做铺垫，对于这几个寄存器的出现应该不难理解。而且，如果我们需要直接操作寄存器的话，一般来说只需要操作前3个寄存器即可。当然，我们现在一般都直接用固件库操作啦。</p>
<p>而对于Systick的应用，我们一般都直接用于实现延时函数，做到精确延时。</p>
<h4 id="2-2-1-延时函数实现原理">2.2.1、延时函数实现原理</h4>
<p>从前面的介绍我们知道，当计数器的值到了我们指定的CNT后，会产生一次中断。</p>
<p>我们可以定义一个变量Delaytime。每次中断的时候都对Delaytime–处理。在延时函数中，我们只需要传入我们想要延时的时长time给Delaytime，判断Delaytime是否为0即可。</p>
<h4 id="2-2-2-配置">2.2.2、配置</h4>
<p>具体操作上，我们只需要调用固件库提供的库函数Systick_Config()即可。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/image-20210424150701067.png" alt="image-20210424150701067"></p>
<p>这个函数只需要我们传入计数器的值，大大的简化了操作步骤，结合前面的简易模型看看：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(1).jpg" alt="定时器简易模型"></p>
<p>那么一般传入参数是多少呢？以stm32f10x系列为例，系统时钟一般为72Mhz，因为单片机执行指令的速度是微秒级的，所以我们一般设定一次中断时间为1ms，即一般传参为72000。</p>
<h3 id="2-3-代码示例">2.3、代码示例</h3>
<p>只讲原理不讲应用示例都是耍流氓。。。</p>
<p>这里我使用野火的指南者实现1s的LED闪烁为举例。</p>
<p>完整工程代码：<a href="https://github.com/yifeianyi/Study-Record">My_Github</a></p>
<h4 id="2-3-1-主函数">2.3.1、主函数</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f10x_it.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span></span></span><br><span class="line">u8 state;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SysTick_Config(<span class="number">72000</span>);</span><br><span class="line">	Led_Init();</span><br><span class="line">	Led_Control(Led_All,OFF);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        Led_Control(Led_All,state);</span><br><span class="line">		Delay_ms(<span class="number">1000</span>);</span><br><span class="line">		state ^=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-中断服务函数">2.3.2、中断服务函数</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u32 Delaytime;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delay_ms</span><span class="params">(u32 time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Delaytime = time;</span><br><span class="line">	<span class="keyword">while</span>(Delaytime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_Handler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Delaytime--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<p>《零死角玩转STM32—F103指南者》</p>
<p>《CM3权威指南CnR2》</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>MCU</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>【初入电子坑系列总纲】自我总结与经验分享</title>
    <url>/2021/04/20/Embedded/MCU/stm32/%E3%80%90%E5%88%9D%E5%85%A5%E7%94%B5%E5%AD%90%E5%9D%91%E7%B3%BB%E5%88%97%E6%80%BB%E7%BA%B2%E3%80%91%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<blockquote>
<p>此文是本人以电子小白的身份，从单片机开始入电子坑以来的自我反省与总结（踩得坑有点多）。也是【初入电子坑】系列个人笔记的索引。</p>
</blockquote>
<a id="more"></a>
<h2 id="本文主要内容">本文主要内容</h2>
<ul>
<li>
<p>导言</p>
</li>
<li>
<p>学单片机的原因</p>
</li>
<li>
<p>前置知识</p>
</li>
<li>
<p>学习经历</p>
</li>
<li>
<p>自我总结与建议</p>
</li>
<li>
<p>笔记索引</p>
</li>
</ul>
<h2 id="导言">导言</h2>
<p>本系列笔记将以stm32单片机为切入点，学习相关的底层原理，以便后续根据需求，可以快速的上手其他型号的单片机。</p>
<p>从目前个人经验来看，初入电子坑，把单片机玩起来还是不太难的。只需要一些相对简单的前置知识即可。后续需要用到，但不在前置知识范围的知识点，会在后续笔记中提及。</p>
<h2 id="学单片机的原因">学单片机的原因</h2>
<p>为什么进电子坑以学单片机为切入点呢？因为单片机又叫MCU(微信控制器)。我们可以通过软件编程，让MCU完成我们想要对物理设备的控制。这里的物理设备可以是机械臂、摄像头、台灯等等等等。</p>
<p>而想要用MCU完成对物理设备的控制，我们理所当然就要学习它的使用方法，想要用它为所欲为的话更是要掌握它的工作原理。这些理由都很充分了吧~</p>
<p>所以，单片机可以看成是跟编程语言一样的东西，下图是我偶像稚晖大佬的表述。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/image-20210421224526675.png" alt="image-20210421224526675"></p>
<p>单片机的芯片型号有很多，每个厂商的都不一样。虽然它们在性能上、操作上各有差异，本质上的作用都是一样的——它是个微型控制器。当我们通过一款单片机入门，学习了相关的底层原理后，学习其他的单片机相对来说就比较简单了。</p>
<h2 id="前置知识">前置知识</h2>
<ul>
<li>初中电学基础知识</li>
<li>C语言</li>
</ul>
<p>具体来说，C语言需要掌握最基本的三种逻辑结构 <strong>顺序、条件、循环</strong> 。且对指针得有一个简单的基本认识，会使用结构体。至于其他的细节，遇到的时候不懂都可以立马现查。</p>
<h2 id="学习经历">学习经历</h2>
<p>刚入门时，买的是正点原子的板子和看他家的视频。但看了几个视屏后发现，正点家的视频省略了很多对没有基础的初学者来说很重要的细节。当时不知道只是因为他家没有说清楚，误认为是自己理解能力的问题。。。学得有点自闭，LED都没点到就弃疗了。</p>
<p>后面想着以赛促学报名了蓝桥杯的嵌入式组，学校的辅导老师让我去看野火的视频学习。发现那边对小白比较友好，而且学习文档写得也很详细，就以此为主要资源学下去了。</p>
<p>但这个教程是16年制作的，教授过程的逻辑还有点不够成熟，经常是细节的地方细节过头，让初学者很容易缺少了对知识本身的整理脉络的掌控。所以有时也会让我看得有点懵逼。（野火家新出的hal库教学视频在原理传授上已经解决了此问题。）</p>
<p>而且我属于有点求知欲过于旺盛。。。总想把所有知识点都扒个底朝天，直接导致学一个知识点的时候冒出了很多个为什么，然后由于自身知识体系的缺失，深入到一定程度的时候就很费力，且研究很久后，还是感觉有点一知半解。</p>
<p>最后，是因为老师每隔一段时间都要我给他汇报最近的学习进况和对相关知识理解。在我每次开始转牛角尖的时候，把我往回拉了一下，才让我放弃了再次弃坑的冲动。。。磕磕碰碰的硬着头皮挺过来。。。</p>
<h2 id="自我总结与建议">自我总结与建议</h2>
<p>比赛确实是促进我们学生党成长的好方法之一。如果不是因为这次报名了蓝桥杯的比赛，我这菜鸡还真不一定能在钻了辣么多次牛角尖的情况下坚持自学下来。</p>
<p>当时寒假还曾因为自己学得慢，在知乎发了这么个问题：</p>
<p><a href="https://www.zhihu.com/question/445146281">对于嵌入式学习，应该克制求知欲吗？嵌入式工作者应该如何把握对原理掌握的深浅？</a></p>
<p>对于这个问题，我现在已经有了自己的答案。</p>
<p>如果身边有老司机能快速解答你心中的疑惑，亦或者这个东西在网上比较容易找到答案的话，那就不应该克制！不要委屈自己，follow your heard~</p>
<p>但这种情况我觉得很多时候，是很难实现的。那么，与其自己死抠那个知识点，不如先跳脱出来，先把程序跑起来。先看到现象，再根据代码理清现象逻辑，再追究它背后的底层原理。这么学习起来应该会轻松愉快很多。</p>
<p>当然就算是以这个流程走，初学的时候，有些涉及到原理背后的设计思想方面的环节，很难找到相关资料的。。。我钻牛角尖的时间基本都耗在这上面了。。。因为我比较贪，我想要的是通过知其所以然，以后转其他平台的时候可以偷多点懒hhh。</p>
<h2 id="笔记索引">笔记索引</h2>
<p>以下是本人以野火stm32指南者视频为主线，夹杂其它参考资料以及个人理解总结的笔记。</p>
<p>对于每个知识点，大致会从 ：</p>
<ul>
<li>这个是什么？</li>
<li>有啥用？为什么需要它？</li>
<li>怎么用（配置）？</li>
</ul>
<p>三个维度去记录。</p>
<h3 id="stm32相关原理">stm32相关原理</h3>
<ul>
<li><a href="https://juejin.cn/post/7000428112286580766">【初入电子坑之stm32篇（一）】初识stm32与寄存器编程</a></li>
<li><a href="https://juejin.cn/post/7000757677584285704">【初入电子坑之stm32篇（二）】固件库编程</a></li>
<li><a href="https://juejin.cn/post/7001118542267416584">【初入电子坑之stm32篇（三）】位带操作</a></li>
<li><a href="https://juejin.cn/post/7001382053820235790">【初入电子坑之stm32篇（四）】理解时钟系统</a></li>
<li><a href="https://juejin.cn/post/7001749982671798285">【初入电子坑之stm32篇（五）】理解中断系统与stm32中断设置</a></li>
<li><a href="https://juejin.cn/post/7002017830992347167">【初入电子坑之stm32篇（六）】定时器基础与Systick</a></li>
<li>【初入电子坑之stm32篇（七）】普通定时器与通用定时器</li>
<li>【初入电子坑之stm32篇（八）】高级定时器</li>
<li>【初入电子坑之stm32篇（九）】USART——串口通信</li>
<li>【初入电子坑之stm32篇（十）】存储器分类</li>
<li>【初入电子坑之stm32篇（十一）】stm32的I2C设置 与 软件模拟</li>
<li>【初入电子坑之stm32篇（十二）】stm32的SPI设置 与 软件模拟</li>
<li>【初入电子坑之stm32篇（十三）】初识DMA 与 stm32的DMA配置</li>
<li>【初入电子坑之stm32篇（十四）】初识ADC 与 stm32的ADC配置</li>
</ul>
<h3 id="单片机通用通信协议：">单片机通用通信协议：</h3>
<ul>
<li><a href="https://juejin.cn/post/7002239233129709575">【初入电子坑之通信入门篇（一）】基础知识</a></li>
<li>【初入电子坑之通信入门篇（二）】串口通信</li>
<li>【初入电子坑之通信入门篇（三）】I2C协议</li>
<li>【初入电子坑之通信入门篇（四）】SPI协议</li>
</ul>
<hr>
<p>未完待续~</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>MCU</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>【初入电子坑之通信入门篇（四）】理解SPI协议</title>
    <url>/2021/02/04/Embedded/MCU/stm32/%E3%80%90%E5%88%9D%E5%85%A5%E7%94%B5%E5%AD%90%E5%9D%91%E4%B9%8B%E9%80%9A%E4%BF%A1%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%91%E7%90%86%E8%A7%A3SPI%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<blockquote>
<p>SPI 协议(Serial Peripheral Interface)，即串行外设接口，是一种高速串行全双工的通信总线。它被广泛地使用在 ADC、LCD 等设备与 MCU 间，要求通讯速率较高的场合。</p>
</blockquote>
<a id="more"></a>
<h2 id="物理层">物理层</h2>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/SPI%E5%8D%8F%E8%AE%AE%E6%A1%86%E5%9B%BE.png" alt="SPI协议框图"></p>
<p>上面是SPI的物理连接图。主要可以分为四部分：</p>
<ul>
<li>SCK：由主机产生，协议不设上面，频率上限主要看设备。</li>
<li>MISO：master input slave output</li>
<li>MOSI：master output slave input</li>
<li>SS：也称为NSS、CS，片选信号线。用于选择从机，一条片选线对应一个从机。</li>
</ul>
<p>拓扑结构上比I2C稍微复杂一丢丢，但十分好理解。</p>
<h2 id="协议层">协议层</h2>
<p>I2C协议只有两根总线，所有信息传输更是只能通过那一根数据总线进行，所以规定了3种传输方式。</p>
<p>而SPI协议有四根线，可操作空间大，自然不比像I2C一样限定多种模式。在传输模式上比较自由，没有固定的传输模式，只需学习原子操作即可。（PS：传输模式其实是有的，不过具体到每个外设的传输模式都不同，还需要具体情况具体分析。）</p>
<h3 id="原子操作">原子操作</h3>
<h4 id="1-起始和停止信号">1）起始和停止信号</h4>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E7%89%87%E9%80%89%E7%BA%BF.png" alt="片选线"></p>
<p>非常简单易看。以连接主机和从机的NSS线状态为准：</p>
<ul>
<li>高——&gt;低：起始信号</li>
<li>低——&gt;高：停止信号</li>
</ul>
<h4 id="2-数据有效性">2）数据有效性</h4>
<p>由于SPI线多，财大气粗，所以相对而言比较随心所欲，没有固定的表示0/1电平的形式。</p>
<p>但究其通信本质，数据信号线的状态无非就三种：</p>
<ul>
<li>空闲没东西发</li>
<li>数据有效</li>
<li>数据无效：01切换的时间</li>
</ul>
<p>所以SPI定义了两个概念：</p>
<ul>
<li>CPOL：clock pole，时钟极性。</li>
<li>CPHA：clock phase，时钟相位。</li>
</ul>
<h5 id="cpol时钟极性">CPOL时钟极性</h5>
<p>定义了时钟线空闲状态时的电平情况。</p>
<ul>
<li>CPOL=0：低电平空闲</li>
<li>CPOL=1：高电平空闲</li>
</ul>
<h5 id="cpha时钟相位">CPHA时钟相位</h5>
<p>SPI的0/1信号 由边沿触发时表示。我们知道，边沿有两不同的状态——上下边沿。而一个时钟周期有两个边沿（上下边沿）。所以要精确的进行数据表示的话，我们必须留出一个边沿来作为电平切换用，即数据无效区。说白的就是一个时钟周期只能传输1位数据。</p>
<p>而CPHA就是定义了具体数据线MOSI和MISO在哪个边沿表示的数据有效。</p>
<ul>
<li>CPHA=0：奇数边沿采样</li>
<li>CPHA=1：偶数边沿采样</li>
</ul>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="时序图"></p>
<p>这个边沿的计数从SS片选线的起始信号开始后，SCK的第一个边沿开始计算。</p>
<h2 id="总结">总结</h2>
<p>至此，对于SPI协议的主干内容就结束了。。。没错，结束了。。。官方文档其余的内容，更多的是关于寄存器和相关参数的内容，协议本身的核心内容就辣么点。</p>
<p>跟I2C相比，SPI协议本身连应答确认机制都没有，十分的简单的粗暴。。。好处是，相对于无标准状态下，各路厂家自由放飞导致的不同厂家间接口不兼容，SPI提供了一个相对普适的基础通信框架。既统一了标准，又给足了厂家们根据自身产品需求对该框架魔改的空间。</p>
]]></content>
      <categories>
        <category>电子</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>【初入电子坑之通信入门篇（三）】I2C协议理解</title>
    <url>/2021/02/02/Embedded/MCU/stm32/%E3%80%90%E5%88%9D%E5%85%A5%E7%94%B5%E5%AD%90%E5%9D%91%E4%B9%8B%E9%80%9A%E4%BF%A1%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%91I2C%E5%8D%8F%E8%AE%AE%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<blockquote>
<p>I2C 通讯协议(Inter－Integrated Circuit)，是一种比较简单的同步串行协议。因其所需引脚少、硬件实现简单、扩展性强，现在广泛用于系统内多个集成电路（IC）间的通讯。</p>
</blockquote>
<a id="more"></a>
<h2 id="目录">目录</h2>
<ul>
<li>物理层</li>
<li>协议层
<ul>
<li>传输过程</li>
<li>原子操作</li>
</ul>
</li>
</ul>
<p>按照学习通讯协议的套路，以下分别讨论I2C的物理层和协议层。</p>
<h2 id="物理层">物理层</h2>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/I2C%E5%B8%B8%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F.png" alt="I2C常用连接方式"></p>
<p>上图中我们可以看到：</p>
<ul>
<li>它只有一条数据线</li>
<li>总线上连接着多个从机（甚至是多个主机）</li>
</ul>
<p>那么以掌握的简单通信知识经验来看，我们可以得出以下初步结论：</p>
<ul>
<li>
<p>如果主机和从机间可以交互，那么这必然是一个半双工的协议</p>
</li>
<li>
<p>一条数据线连接着多个设备，可能存在多个设备访问总线产生数据冲突问题</p>
</li>
<li>
<p>每个设备必然有一个独立地址</p>
</li>
</ul>
<p>带着以上的初步认识去看协议具体内容，我们可以很快的接受并记住I2C的物理层特性。</p>
<h3 id="物理层特性">物理层特性</h3>
<ol>
<li>它是一个支持设备的总线。可连接多个 I2C 通讯设备，支持多个通讯主机、从机。</li>
<li>每个连接到总线的设备都有一个独立的地址。</li>
<li>总线通过上拉电阻接到电源。当 I2C 设备空闲时，会输出高阻态，而当所有设备都空<br>
闲，都输出高阻态时，由上拉电阻把总线拉成高电平</li>
<li>多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。</li>
<li>具有三种传输模式：标准模式传输速率为 <strong>100kbit/s</strong> ，快速模式为 <strong>400kbit/s</strong> ，高速模式下可达 <strong>3.4Mbit/s</strong>。</li>
<li>连接到相同总线的 IC 数量受到总线的最大电容 400pF 限制 。</li>
</ol>
<h2 id="协议层">协议层</h2>
<p>协议层定义了：</p>
<ul>
<li>起始和停止信号</li>
<li>数据有效性</li>
<li>响应</li>
<li>仲裁</li>
<li>时钟同步和广播地址</li>
</ul>
<p>说白的就是定义了在传输过程中01串的意义。</p>
<h3 id="传输过程">传输过程</h3>
<p>我把起始和停止信号、响应信号等基本最基础的操作，称为原子操作。</p>
<p>在讨论原子操作具体如何实现前，让我们先对I2C的传输过程有个整体认识。</p>
<p>大致上，I2C的传输过程有这么三种情况：写、读、读写混合</p>
<h4 id="写过程">写过程</h4>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/I2C%E5%86%99%E8%BF%87%E7%A8%8B.png" alt="I2C写过程"></p>
<p>由上图可知，整个写过程由以下部分组成：</p>
<ul>
<li>发送起始信号</li>
<li>从机地址</li>
<li>传输模式——写模式</li>
<li>应答信号（表示从机接收到信号stanby了）</li>
<li>主机发送n字节数据</li>
<li>应答or非应答信号</li>
<li>若是非应答or主机不想收，则主机发送停止信号</li>
</ul>
<p>这是个很严谨的过程，每发送一个具体都需要等待对方的应答，只有确定接收端收到之后，才会继续发送数据。在最大程度上保证了数据传输的可靠性。</p>
<p>值得注意的是，这里的从机地址协议规定了可以选7位或10位，不过绝大多数情况下都是使用7位地址。</p>
<h4 id="读过程">读过程</h4>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/I2C%E8%AF%BB%E8%BF%87%E7%A8%8B.png" alt="I2C读过程"></p>
<p>整个读过程由以下部分组成：</p>
<ul>
<li>发送起始信号</li>
<li>从机地址</li>
<li>传输模式——读模式</li>
<li>应答信号（表示从机接收到信号stanby了）</li>
<li>主机发送n字节数据（单次发送8位）</li>
<li>应答or非应答信号</li>
<li>若是非应答则，主机发送停止信号</li>
</ul>
<h4 id="读写混合模式">读写混合模式</h4>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/I2C%E8%AF%BB%E5%86%99%E6%B7%B7%E5%90%88%E8%BF%87%E7%A8%8B.png" alt="I2C读写混合过程"></p>
<p>读写混合过程相较于单独读、写模式来说，复杂了一丢丢。</p>
<p>它一次通讯有两次操作过程：</p>
<ul>
<li>第一次告诉目标从机的要读写的地址</li>
<li>第二次对目标读写地址进行实际操作</li>
</ul>
<p>具体过程有以下部分：</p>
<ul>
<li>起始信号</li>
<li>从机地址</li>
<li>传输模式——读模式</li>
<li>应答信号（表示从机接收到信号stanby了）</li>
<li>主机发送需要读取的目标地址</li>
<li>应答信号</li>
<li>二次起始信号</li>
<li>选择同样的从机</li>
<li>修改输出模式——写模式</li>
<li>应答信号</li>
<li>发送or读取n字节数据</li>
<li>应答信号</li>
<li>终止信号</li>
</ul>
<p>据本人初步学习分析，之所以有三种模式，应该是对应于三种不同个需求：</p>
<ul>
<li>只需要输出的，应该是诸如显示器一类</li>
<li>只需要读取的，应该是传感器的数据</li>
<li>像读写混合这样先定位准确的位置，再读写数据的，应该只能是存储器了</li>
</ul>
<h3 id="原子操作">原子操作</h3>
<p>以上传输过程相对来说，还比较宏观。下面我们看看I2C在是如何实现以上种种信号的。</p>
<p>以下实现皆为协议具体设计，是人为定位的，虽有一定内在设计逻辑在里面，但只需记住定义即可。</p>
<h4 id="起始和停止信号">起始和停止信号</h4>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E8%B5%B7%E5%A7%8B%E5%92%8C%E5%81%9C%E6%AD%A2%E4%BF%A1%E5%8F%B7%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="起始和停止信号时序图"></p>
<p>同时满足以下条件时，便是起始信号：</p>
<ul>
<li>SCL高电平</li>
<li>SDA由高电平转低电平时，注意，是电平转换时！！！</li>
</ul>
<p>同时满足以下条件时，便是终止信号：</p>
<ul>
<li>SCL高电平</li>
<li>SDA由低电平转高电平</li>
</ul>
<h4 id="数据表示">数据表示</h4>
<p>也叫数据有效性，它具体定义了01数据的电平表示。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E6%95%B0%E6%8D%AE%E6%9C%89%E6%95%88%E6%80%A7.png" alt="数据有效性"></p>
<p>1的表示：</p>
<ul>
<li>SCL高电平</li>
<li>且SDA为高电平</li>
</ul>
<p>0的表示：</p>
<ul>
<li>SCL高电平</li>
<li>且SDA为低电平</li>
</ul>
<p>而当SCL为低电平时，SDA没有任何意义，这时候就是01表示切换的时机。</p>
<p>由以上定义可以看出，I2C一个时钟周期只能传输1位数据。</p>
<p>小结上面几点就是：<strong>SCL为高电平时，数据有效。</strong></p>
<h4 id="地址及数据方向">地址及数据方向</h4>
<p>协议定义了地址为7位 or 10位，这个自己选，一般选7位。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E5%9C%B0%E5%9D%80%E5%8F%8A%E6%96%B9%E5%90%91.png" alt="地址及方向"></p>
<p>原因很简单，单字节就是8位。地址位7位+方向位恰好是一个字节。</p>
<p>所以对应的也引申出了两种需要注意的地址叫法：</p>
<ul>
<li>最高的7位数据——从机地址</li>
<li>整个8位数据——写地址/读地址</li>
</ul>
<h4 id="响应">响应</h4>
<p>接收端每次接受完一个字节信号后，都要向发送端发送一个应答（ACK）或者不应答（NACK）信号。</p>
<p>协议规定了这个信号在传输一个字节数据后的第9个时钟周期产生。</p>
<p>这时，若SDA为低电平，则表示应答信号，反之为非应答信号。</p>
<h2 id="小结">小结</h2>
<p>有了以上对I2C协议的理解后。会发现，说白的xxx通讯协议，就是控制电平按照协议标准的方式在总线上变化。只要能实现协议规定的特征电平，就能实现该协议。所以无论是软件还是硬件都可以实现这个协议通信。区别在于，软件实现会消耗CPU资源，而硬件通信可以减少CPU的负担。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>【初入电子坑之通信入门篇（一）】通信基础概念</title>
    <url>/2021/01/21/Embedded/MCU/stm32/%E3%80%90%E5%88%9D%E5%85%A5%E7%94%B5%E5%AD%90%E5%9D%91%E4%B9%8B%E9%80%9A%E4%BF%A1%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%91%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>通信是嵌入式的重要组成部分，本人简单试水过后发现此坑略深，以目前应用为主的策略来看，不宜陷得太深。所以这系列笔记文章主要围绕“这是什么？”“它的大致原理是什么？”展开讨论。基本上会忽略绝大多数诸如“为什么需要它？/它是怎么顺理成章的推出来的？”的这类问题。（因本人才疏学浅，若有叙述不当之处，恳请各位大佬指正。）</p>
</blockquote>
<a id="more"></a>
<h2 id="目录">目录</h2>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/image-20210427232632309.png" alt="image-20210427232632309"></p>
<h2 id="一-通信本质">一、通信本质</h2>
<p>通信通信，说白的就是信息互通。人跟人间的信息互通、机器跟机器间的信息互通、机器跟人间的信息互通。</p>
<p>而想要做到互通，主要有两个问题需要解决，“<strong>信息该如何表示？</strong>”和“<strong>信息该如何传输？</strong>”两个核心问题。</p>
<p>我们知道信息交互中，最原始、朴素的表示是0和1。其中，信息传输主要指01串在传输介质上传输的过程。这个过程具体上跟诸如无线电、光纤、电缆如何操作实现有关，不在本文讨论范围。所以本文主要讨论的是“信息该如何表示？”这一问题。</p>
<p>那么：</p>
<ul>
<li><strong>在电子世界中如何表示0和1？</strong></li>
<li><strong>信息的发送方和接收方如何解析？</strong></li>
<li><strong>如何用0和1的组合表示我们所要传达的信息？</strong></li>
</ul>
<p>就是值得讨论的问题了。</p>
<h2 id="二-信息表示">二、信息表示</h2>
<h3 id="2-1-01信号表示">2.1、01信号表示</h3>
<p>首先，在电子世界中0和1的表示，目前大致有两种方式：</p>
<ul>
<li>电平信号</li>
<li>差分信号</li>
</ul>
<h4 id="2-1-1-电平信号">2.1.1、电平信号</h4>
<p>电平信号，简单来说就是根据一根线上的不同电压区间划分成高电平和低电平（如：大于3.3v为高电平，低1.5v为低电平等），通过人为定义高电平为0或1来传输信息。</p>
<p>而又因为几乎不可能做到不同设备间电压完全一致，所以为了保证收发双方电压的一致性，电平信号传输通常需要再加一根GND线作共地用。（图中两个矩形为通信的两个设备）</p>
<img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%94%B5%E5%B9%B3%E4%BF%A1%E5%8F%B7%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="电平信号示意图" style="zoom: 25%;" />
<h4 id="2-1-2-差分信号">2.1.2、差分信号</h4>
<p>差分信号这哥们可以说是电平信号的弟弟。前人发现，在长距离信息传输时，传输线会变成不可忽略的等效电阻，从而造成明显的压差，致使信息丢失、失真等现象。而且电平信号只有一根数据线，容易受到电磁干扰等等。</p>
<p>因以上原因，差分信号线就粉嫩登场。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/ECCF8208F5537612CDDCCC2E9DF202E7.png" alt="img"></p>
<p>既然你一根信号线容易受电磁干扰、长距离传输有明显压差，那么我用两根信号线表示，根据两根信号线同一时刻的压差区间定义0和1不就可以增强抗干扰性和增长了传输距离嘛。这就是差分信号的思想。</p>
<p>但差分信号也不是没有缺点的。</p>
<p>它的问题在于线材的花销是电平信号的两倍。当我们同时传输n路信号时，电平信号只需要n+1根线（n根信号线，1根共线线），而差分需要2n根线。所以电平信号和差分信号本身并无优劣之分，主要看使用场景进行选择。</p>
<h3 id="2-2-信号解析">2.2、信号解析</h3>
<p>信号解析的操作过程而言，其实就是信号解码的过程。发送方通过对01串进行编码发送给接收方，而接收方通过之前约定的编码规则逆向解析。</p>
<p>这个发送和接收的过程中会产生两个问题：</p>
<ul>
<li>接收方怎么知道发送方什么时候发送了信息？</li>
<li>如果发送了信息，又发送了多少信息？</li>
</ul>
<p>由以上两个问题可以引申出两种不同的通信方式：</p>
<ul>
<li>同步通信</li>
<li>异步通信</li>
</ul>
<h4 id="2-2-1-同步通信">2.2.1、同步通信</h4>
<p>同步通信，在表现形式上就是在收发双方之间加了一条时钟线。通过结合时钟线SCL的电平状态和信号线SDA的电平状态组合出诸如：起始信号、终止信号、实际想要发送的0/1信号等。</p>
<p>如单片机中最常用的I2C协议，它的起始和终止信号就是通过判断时钟线SCL在高电平时，信号线SDA的边沿跳变情况决定的。（关于I2C的具体内容，不了解的朋友可以自行搜索学习。）下图为同步通信示例，I2C协议的拓扑连接图。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/I2C%E5%B8%B8%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F.png" alt="I2C常用连接方式"></p>
<h4 id="2-2-2-异步通信">2.2.2、异步通信</h4>
<p>异步通信跟同步通信的最大区别在于——异步通信没有时钟线，只有信号线和地线。</p>
<p>既然没有的时钟线作为辅助，那么信号线SDA就需要传输包含更多的信息，以替代时钟线的作用。诸如：</p>
<ul>
<li>我们接收方需要知道收到怎样的信号时表示一个数据的开始。</li>
<li>怎样的信号表示一个信号的结束。</li>
<li>怎样的信号表示需要传递的数据本身。</li>
</ul>
<p>因此，异步通信传输的01串里，必然需要包含起始位、停止位，以及真正需要传输的数据的数据长度。</p>
<p>不仅如此，我们还需要统一一下收发双方的传输速率，以便接收方能及时且准确的处理发送方发来的数据。</p>
<p>这个传输速率，我们一般称为<strong>波特率</strong>。波特率指的是每秒钟传送的码元的个数。至于码元是啥。。。由于本人太菜，这个概念的实际内涵还没理解透彻。但在通信过程中，常常一个码元等于一个比特，所以在通信过程中，波特率在大多数情况下，可以理解为<strong>比特率</strong>。即每秒钟传送得到比特个数。</p>
<h4 id="2-2-3-小结">2.2.3、小结</h4>
<h5 id="同步通信：">同步通信：</h5>
<p>​	<strong>优点：</strong><br>
​		1、可以根据不同时钟线边沿的不同，判断信息的采集与否。<br>
​		2、不用添加额外的状态位，增加了信息传输密度。</p>
<p>​	<strong>缺点：</strong><br>
​		1、需要时钟线协调。<br>
​		2、占用发送端和接收端双方的资源（收发双方都需要，时刻关注时钟线的）。</p>
<h5 id="异步通信：">异步通信：</h5>
<p>​	<strong>优点：</strong><br>
​		1、不需要额外的信号线，所占用线较少。<br>
​		2、只占用接收端的资源（需要时刻关注数据线的电平变化情况，但发送方不用）。<br>
​	<strong>缺点：</strong><br>
​		1、需要状态位表示收发状态。<br>
​		2、需要协定信息传输速率协同双方的信息处理。</p>
<h5 id="比较结论：">比较结论：</h5>
<ul>
<li>同步通信比异步传输效率更高，适合信息交互频繁的场合。</li>
<li>异步通信，相对整体占用资源较少，适用信息交互相对较少的场合。</li>
</ul>
<h3 id="2-3-通信协议">2.3、通信协议</h3>
<p>知道了0/1如何表示，也知道了收发双方对信号解析应该注意的事项。那么就还剩最后一个重要的问题了，即：<strong>如何用0和1的组合表示我们所要传达的信息？</strong></p>
<p>换句话说，对于一大串01序列应该如何解读？</p>
<p>这个问题就属于编码的范畴了，如何编码是通信协议规定的。不同的协议有不同的编码方式，这个在学习具体通信协议时会感受到。但它们无外乎遵从以下几点：</p>
<ul>
<li>0/1表示</li>
<li>信号解析</li>
<li>编码方式</li>
<li>传输方向</li>
</ul>
<p>传输方向前面没有提到，这里简单的介绍下。</p>
<h4 id="2-3-1-传输方向">2.3.1、传输方向</h4>
<p>通信的传输方向可以分为以下三种：</p>
<ul>
<li>单工通信：任何时刻都只能单向传输信息。</li>
<li>半双工通信：同一时刻只能单向传输信息，即在通信过程中可以改变传输方向。</li>
<li>全双工通信：任何时刻都可以双向传输信息。</li>
</ul>
<p>由以上定义其实可以看出，一般单工和半双工都是通过一根信号线实现的，而想要实现全双工，则需要两根信号线用两个端口接收。</p>
<h4 id="2-3-2-常见通信协议">2.3.2、常见通信协议</h4>
<p>有关通信协议的主要问题，个人觉得有上面的理解差不多够了。下面是简单介绍下载单片机中常用到的通信协议：</p>
<ul>
<li>串口协议：皆为异步协议。
<ul>
<li>RS-232：电平信号</li>
<li>RS-485：差分信号</li>
</ul>
</li>
<li>I2C总线协议：同步半双工协议（电平信号）</li>
<li>SPI总线协议：同步全双工协议（电平信号）</li>
<li>。。。。。。</li>
</ul>
<h2 id="三-缓存方式">三、缓存方式</h2>
<p>在通信过程中，缓存机制是很有必要，至于为什么，请看下图：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E7%BC%93%E5%AD%98%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7.png" alt="缓存的必要性"></p>
<p>接收端其实也是同样的道理，由此看出缓存机制的必要性。</p>
<p>而常见的缓存机制有两种：</p>
<ul>
<li>FIFO</li>
<li>DMA</li>
</ul>
<p>学过数据结构的朋友对FIFO应该都不陌生，first in first out,先进先出的队列结构。</p>
<p>还是发送端为例，应用到上述过程中的话，就是cpu把要传的数据先丢给寄存器，由该寄存器一个bit一个bit的丢给发送端口，CPU就去干其他的活了。</p>
<p>但寄存器的存储空间很有限，很多情况下还是要把需要发送数据拆分成多个段落分次传输，所以引申了一个原理类似，但比寄存器存储空间要大的缓存机制——DMA。</p>
<p>更多关于DMA的讨论，我们后面再聊~</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>【初入电子坑之stm32篇（五）】理解中断与stm32中断配置</title>
    <url>/2021/01/19/Embedded/MCU/stm32/%E3%80%90%E5%88%9D%E5%85%A5%E7%94%B5%E5%AD%90%E5%9D%91%E4%B9%8Bstm32%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89%E3%80%91%E7%90%86%E8%A7%A3%E4%B8%AD%E6%96%AD%E4%B8%8Estm32%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>按照个人习惯，本文将从“这是啥？”“为啥需要它？”“如何操作？”三个角度展开讨论分析。</p>
</blockquote>
<a id="more"></a>
<h2 id="目录">目录</h2>
<ul>
<li>中断简介</li>
<li>中断理解</li>
<li>stm32中的中断设置
<ul>
<li>NVIC</li>
<li>stm32中断配置</li>
</ul>
</li>
<li>总结</li>
</ul>
<h2 id="中断简介">中断简介</h2>
<p>中断，即机器运行过程中出现某些意外情况，需机器停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E4%B8%AD%E6%96%AD%E7%AE%80%E4%BB%8B.jpg" alt=""></p>
<h2 id="理解中断">理解中断</h2>
<p>想象一下这么一个场景：</p>
<p>你在认真的敲代码，你妈喊你出房间去客厅恰饭，并且以不出来就拔网线为威胁。这时候你能怎么办？只能乖乖保存好文档，然后去恰饭，恰完再回来打开之前的文件继续敲咯。</p>
<p>我们分析一下上述的场景：</p>
<ul>
<li>正在敲代码——<strong>当前执行的事件</strong></li>
<li>你妈喊你吃饭——<strong>中断源</strong></li>
<li>你听到你妈喊你吃饭——<strong>接受到中断请求</strong></li>
<li>威胁你——<strong>事件优先级别高</strong></li>
<li>保存已经写好部分——<strong>保存现场</strong>（中断响应）</li>
<li>去恰饭——<strong>执行中断事件</strong></li>
<li>恰饭回房间——<strong>中断返回</strong></li>
<li>打开文件继续敲码——<strong>恢复现场</strong></li>
</ul>
<p>对于机器来说也是一样的。无论是内核出现问题（异常），还是因为存在其他比当前正在执行的程序的优先级更高的事件发生（外部中断），都会打断当前运行的程序，去处理更加重要的事。</p>
<p>毕竟，机器的运算速度再快，处理事件也有先后之分不是？</p>
<p>接下来，让我们再次回到刚刚那个场景，考虑下面两种情况：</p>
<p>1、当正在吃饭的时候，你忽然想去WC解决下个人问题。这时你会停止恰饭这个动作，然后去WC解决完再回来继续吃饭。吃完饭才会继续</p>
<p>2、当正在吃饭的时候，你收到快递小哥的短信，告诉你丰巢的验证码可以去取的时候。你肯定会先恰完饭，然后去取完快递之后（也可能先在那放着先不取）再回房间敲代码。</p>
<p>对于情况1而言，为了避免某些比较尴尬的事情发生，先去WC再回来吃饭几乎是必然选择。因为它比吃饭紧急。而对于情况2取快递，相对来说没那么急迫的需求，所以一般而言我们都会先吃完饭，再去拿快递，最后再回房间敲代码。</p>
<p>当然如果要敲的代码比较着急，那么拿快递这件事自然就得等到我们敲完代码先啦。</p>
<p>从上面两个常见的场景中，我们很容易发现中断是可以嵌套的，且它有一定的优先级概念。</p>
<p>很显然，我们的日常生活中也会有许多中断事件。我们人脑是怎么处理它们的？认真思考下下不难发现，其实对于很多事件，我们早就给它们定义了优先级。而定义这些事件的优先级并严格执行的就是我们的大脑。</p>
<p>对于 CPU来说也一样。当中断事件很少的时候，不需要分门别类的整理，直接比较判断优先级就可以了。</p>
<p>而对于中断事件较多的复杂系统，对于事件的分组和优先级设置也就成了刚需。</p>
<p>下面我们以stm32f10x的中断系统为例，展开学习。</p>
<h2 id="stm32中的中断设置">stm32中的中断设置</h2>
<p>我们知道，stm32用的是cortex-M3内核。</p>
<p>而CM3内核支持256个中断，256级可编程设置（即优先级设置），其中：</p>
<ul>
<li>内核中断16个</li>
<li>外设中断240个</li>
</ul>
<p>但stm32并没有把CM3内核的设置全部用上。<br>
它仅有84个中断，16级可编程设置，其中：</p>
<ul>
<li>内核中断16个</li>
<li>外设中断68个</li>
</ul>
<p>且以上配置属于stm32中的顶配，具体到 f103系列只有：</p>
<ul>
<li>内核中断16个</li>
<li>外设中断44个</li>
</ul>
<p>小结下以上的数据，可以发现，实际中断事件的多少取决于芯片的定位。高端的，即外设多的，芯片中断必然多，反之必然少。</p>
<h3 id="nvic">NVIC</h3>
<p>而要处理那么多的中断事件，CM3内核给出的解决方案是——用NVIC (Nested Vectored Interrupt Controller)嵌套向量中断控制器控制。</p>
<p>NVIC首先定义了一段地址区域（一般从0地址开始）用于存放中断事件服务函数的地址。定义的这段地址就称为<strong>中断向量表</strong>。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E4%B8%AD%E6%96%AD%E5%90%91%E8%A1%A8%E8%A1%A81.png" alt="中断向表表1"></p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A82.png" alt="中断向量表2"></p>
<p>以上是从《stm32f10x 中文参考手册》中截来。</p>
<p>可以看到它一个地址对应着一个中断事件，其中灰色部分是内核相关的中断的位置。每当一条指令执行完之后，系统都会检查一遍看看有没有中断事件发生。如果有的话，就会在中断向量表中找到对应的中断事件，执行中断事件所在地址指向的函数（即中断函数）。</p>
<p>也就是因为中断事件所在的地址存的是一个地址，它指向的是该中断对应发生的事件（函数）。所以其实中断向量表这个名字起得很符合它的实际含义——<strong>表里的是一个个有指向的值</strong>。</p>
<p>至于定义这些中断事件的优先级和它们具体是干嘛的，NVIC把设置的权利交给了开发者，它只给了可以完成相关操作的寄存器组。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/NVIC%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="NVIC结构体"></p>
<p>从固件库头文件：core_cm3.h中，我们可以找到以上NVIC的寄存器组映射。</p>
<p>其中如果我们使用寄存器编程的话，最关心的寄存器一般是：</p>
<ul>
<li>ISER：Interrupt Set Enable Register，中断使能设置寄存器</li>
<li>ICER：Interrupt Clear Enable Register，中断使能清除寄存器</li>
<li>IP：Interrupt Priority Register，中断优先级寄存器</li>
</ul>
<p>在这里面，中断优先级寄存器是需要我们着重研究的。有意思的是，固件库命名的时候对于该寄存器的简写直接只用IP，而不是IPR，害我一度怀疑这两是不是同一个东西。直到我去查了手册才验明了“真身”。</p>
<h4 id="ipr中断优先级寄存器">IPR中断优先级寄存器</h4>
<p>原CM3设计中，NVIC_IPRx用于配置外部中断的优先级。IPR宽度为8bit，理论上可以配置的优先级为0~255，数值越小优先级越高。但和大多数CM3芯片都会精简设计一样，stm32也做了相关的精简设计，只使用高4bit。也就是说，实际上stm32允许配置的优先级只有16个</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/IPR%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84.png" alt=""></p>
<h4 id="抢占优先级与子优先级">抢占优先级与子优先级</h4>
<p>CM3把优先级划分成了抢占优先级和子优先级（又叫响应优先级）。即，对于同一个中断事件，他有抢占优先级和子优先级两个优先级。</p>
<h5 id="为什么要这么设置？">为什么要这么设置？</h5>
<p>因为如果只是简单的只有一种优先级的话，太过粗线条了。像CM3内核设置最多有256级，即使是stm32也有16级，级数太多，没有主次不方便使用和管理。</p>
<p>类比到我们平时生活中的状态，就像社会上有256个人，每个人都不同级别一样，估计你会眼花缭乱。而解决这个问题的方法就是那就是把这256级中断归类分层，层级内再分子级的分层管理形式，达到压缩层级的效果。 如先分统治阶层、奴隶主、奴隶等，同一阶层再区分小级别。</p>
<p>对应于中断分组就是，把256级优先级根据本工程的需求，先规定了中断层数(即：抢占优先级)和每层有多少小级别个数。</p>
<p>这样抢占优先级和子优先级的概念引进我们就完全可以理解了。</p>
<h5 id="抢占优先级-与-子优先级-比较">抢占优先级 与 子优先级 比较</h5>
<p>只有当抢占优先级相同的时候，子优先级才会发挥作用。若子优先级也相同，就去比较两个外设的硬件中断编号，即该中断在中断向量表中的位置，同样是编号越小，优先级越高原则。</p>
<p>值得注意的是 抢占优先级 与 子优先级 还有些许差别：</p>
<ul>
<li>抢占优先级：无关中断产生的先后，只比较优先级的高低。优先级高的中断信号即使比中断优先级低的中断信号后到，也可以直接中断优先级低的事件<strong>直接抢占系统资源</strong>。</li>
<li>子优先级：当两个中断信号有相同的抢占优先级，分两种情况考虑：
<ul>
<li>两个信号同时到达，子优先级高的中断先响应。</li>
<li>子优先级低的中断事件正在发生，子优先级高的中断信号刚到时，需要等到当前中断完成后，在执行玩到的中断信号。</li>
</ul>
</li>
</ul>
<h4 id="中断分组">中断分组</h4>
<p>从前面的讨论中我们可以知道，为了中断更加可控，CM3内核做了两种优先级的分层机制。</p>
<p>但是对于不同的需求，我们对于阶层和小阶级的数量要求也是不同的。以身份证为例，在发放身份证之前，我们要总体考虑全国要分多少个区域，然后确定地区需要设置几位数才够。熟悉计算机网络的朋友可以发现，这里其实和子网划分是一个道理。</p>
<p>到这里，我们也可以看到，在一个工程中，我们一般只会设置一次，且每次只设置一个分组。还是拿身份证举例，你不可能前一秒还说身份证前3位表示A省，下一秒就说前4位表示B省吧？编码格式统一是一切的基础。</p>
<p>所以，我们平时在设置分组时，若不是非常特殊的需求</p>
<p><font color=red><strong>一个工程只设置一次分组!!!</strong></font></p>
<p><font color=red><strong>一个工程只设置一次分组!!!</strong></font></p>
<p><font color=red><strong>一个工程只设置一次分组!!!</strong></font></p>
<p>重要的事情说三遍。。。</p>
<p>这个分组管理的设置由内核外设SCB_AIRCR（应用程序中断及复位控制寄存器）的prigroup[10:8]控制。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/SCB_AIRCR.png" alt="SCB_AIRCR"></p>
<p>因为它通过3个bit控制，所以理论上可以分成8组（0~7组），其中每组可设置的抢占优先级和子优先级的位数是不同的。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/CM3%E4%B8%AD%E6%96%AD%E5%88%86%E7%BB%84%E5%AE%8C%E6%95%B4%E5%9B%BE.png" alt="CM3中断分组完整图"></p>
<p>如上图，可以看到它随着组号的增大，抢占优先级可设置的位越少，子优先级越多。</p>
<p>上面这种分组是针对IPR里8bits都用上的情况设计的。而我们知道，stm32的NVIC是CM3的NVIC的子集，只用了IPR的高4bits，所以分组自然而然就少了。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/stm32%E4%B8%AD%E6%96%AD%E5%88%86%E7%BB%84%E5%AE%8C%E6%95%B4%E5%9B%BE.png" alt="stm32中断分组完整图"></p>
<p>有了以上的原理性认知，我们终于进入到轻松愉快的编程配置环节~~~</p>
<h4 id="配置要点">配置要点</h4>
<p>根据前面叙述的内容，辅以一些额外资料（诸如各种官方文档），我们可以得出以下配置流程：</p>
<ul>
<li>使能某个的中断</li>
<li>中断分组</li>
<li>初始化NVIC_InitTypeDef 结构体
<ul>
<li>设置中断源</li>
<li>设置抢占优先级和子优先级</li>
<li>配置中断使能/失能</li>
</ul>
</li>
<li>编写中断服务函数（就是这个中断发生后，告诉机器去干嘛）</li>
</ul>
<p>上面流程中提到的NVIC_InitTypeDef结构体，就是这哥们儿：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/image-20210316182454196.png" alt="image-20210316182454196"></p>
<p>它跟NVIC_Type结构体的区别在于，NVIC_Type只是寄存器组的映射，而NVIC_InitTypeDef是固件库抽象提炼出来帮助我们简化配置流程用的。</p>
<p>下面，我们用一个实例体会下上述过程。</p>
<h3 id="exti">EXTI</h3>
<p>EXTI（External interrupt/event controller）—外部中断/事件控制器，用于管理了控制器的 20个中断/事件线（互联型才有20根，其他类型只有19根）。</p>
<h4 id="nvic与exti的关系">NVIC与EXTI的关系</h4>
<p>我们先来理一理这东西跟NVIC的关系：</p>
<ol>
<li>NVIC是CM3内核的东西，它用于整个芯片的中断控制。而EXTI是ST公司设计用于控制外设的。它不是内核里面的东西。</li>
<li>EXTI通过魔改引出NVIC中的20根中断信号线，对外设事件的控制能力进一步加强了。</li>
</ol>
<p>在这里，我们先理清三个概念：</p>
<ul>
<li>事件</li>
<li>中断</li>
<li>中断事件</li>
</ul>
<p>比如一老师在教室里给学生们上课。课堂上的学生可能做出各种行为动作，比方做笔记、打哈气、翻书包、讲小话等，我们把这些行为统称为<strong>事件</strong>，其中有些行为老师往往只是视而不见，继续他的上课；而有些行为可能导致老师的上课中止，比方讲小话，并对学生的相关行为予以警告、批评或纠正等，然后继续上课。我们把老师因为学生的某些行为而中止授课，并产生后续动作，之后接着上课的这个过程理解为<strong>中断或中断响应</strong>。我们把可能导致老师上课中断的学生行为理解为<strong>中断事件</strong>。</p>
<h4 id="exti框图理解">EXTI框图理解</h4>
<p>下面，我们结合EXTI的框图理解上述概念。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/EXTI%E6%A1%86%E5%9B%BE1.png" alt="EXTI框图1"></p>
<p>首先，我们先对整个框图有个大概的认知：</p>
<ul>
<li>绿色+红色部分：跟外设连接在一起。绿色部分用于和蓝色部分信息交互，红色部分用于传输事件信号。</li>
<li>蓝色部分：寄存器组，用于控制事件信号的采集和走向。</li>
<li>黄色部分：两个输出端。用于事件信号的输出，中断信号去NVIC，非中断信号用于其他外设（如:DMA，DMA相关内容，在后续文章会详细说明）。</li>
</ul>
<p>EXTI 可分为两大部分功能，一个是产生中断，另一个是产生事件，这两个功能从硬件上就有所不同。</p>
<h5 id="信号产生过程">信号产生过程</h5>
<p>下面我们来分析下这两者的产生过程。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/image-20210316182718811.png" alt="image-20210316182718811"></p>
<p>如上图，信号首先会经过<strong>边沿检测电路</strong>，这个检测电路会通过查看 <strong>上边沿触发</strong> 和<strong>下边沿触发</strong> 寄存器的值，去判断信号到底在哪个边沿采集。（所谓上边沿和下边沿，即电平从低-&gt;高  or 从高-&gt;低 变化时的那条竖直的边）</p>
<p>经过边沿检测电路之后，就来到上图中3的位置。这里是个或门连接着输入信号和软件中断事件寄存器。也就是说，除了信号触发中断，我们还可以控制相关的寄存器从而产生中断事件。</p>
<p>过了步骤3或门这一步之后，产生中断和产生事件的流程就有所区别了。</p>
<p>我们先来看看中断的产生过程：</p>
<p>首先中断请求信号会先进入 <strong>请求挂起寄存器</strong> 。这个寄存器的存在意义在于，如果中断发生时，正在处理同级或高优先级中断，则中断不能立即得到响应，此时中断被悬起。悬挂意味着等待而不是舍去，当优先级高的或者同等级先发生的中断完成后，被挂起的中断才会执行。</p>
<p>落实到stm32这里，可以看到在标号4的位置，是一个与门，所以，中断请教什么时候推送到NVIC控制器执行，就是<strong>中断屏蔽寄存器</strong>应该控制的事了。</p>
<p>同理，对于事件发生来说，事件是否生成，就是事件屏蔽寄存器的事了。不同点在于，事件的产生没有优先级的概念，所有无需挂起寄存器这么个东西。</p>
<h4 id="代码示例">代码示例</h4>
<hr>
<p>未完待续~</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="http://www.openedv.com/forum.php?mod=viewthread&amp;tid=275496&amp;page=1&amp;authorid=105694">关于STM32中断优先级分组的科普，初学者常见问题解答</a></p>
<p><a href="https://blog.csdn.net/tanyjin/article/details/53359883?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control">STM32的“外部中断”和“事件”区别和理解</a></p>
<p><a href="https://blog.csdn.net/weixin_45590473/article/details/108039950?utm_term=stm32%E4%B8%AD%E6%96%AD%E6%8C%82%E8%B5%B7&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-2-108039950&amp;spm=3001.4430">浅谈中断挂起与中断标志的区别</a></p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>MCU</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>【初入电子坑之stm32篇（四）】理解时钟系统</title>
    <url>/2021/01/17/Embedded/MCU/stm32/%E3%80%90%E5%88%9D%E5%85%A5%E7%94%B5%E5%AD%90%E5%9D%91%E4%B9%8Bstm32%E7%AF%87%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%91%E7%90%86%E8%A7%A3%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>时钟系统是MCU必不可少的一部分。本文将针对以下问题展开讨论：</p>
<ul>
<li>什么是时钟？</li>
<li>如何理解stm32时钟结构？</li>
<li>为什么MCU会有多个时钟源？</li>
<li>stm32如何配置时钟？</li>
</ul>
<p>当然，由于本人学识不足，且时钟略复杂，所以这里只能说是对时钟有一个感性的初步理解，如有错误，还望不吝指正。</p>
</blockquote>
<a id="more"></a>
<h2 id="目录">目录</h2>
<ul>
<li>一、时钟简介</li>
<li>二、stm32时钟树</li>
<li>三、关于时钟的一些思考</li>
<li>四、时钟配置分析</li>
<li>五、总结</li>
</ul>
<h2 id="一-时钟简介">一、时钟简介</h2>
<p>首先我们得搞清楚几个概念：</p>
<ul>
<li>时钟：单片机的心脏，所有外设的运作都需要时钟供能。</li>
<li>时钟周期：又称为振荡周期，可以简单理解为传输一个 0 or 1 所需要的时间。</li>
<li>指令周期：执行一条指令（如：MOV A，#34H）所需的时间。对于不同类型的指令，指令周期长度可能会不同。</li>
<li>机器周期：执行一个动作的时间周期。如：执行一个指令需要 “取指令并驿码”、&quot;执行操作数&quot;两个动作。</li>
</ul>
<p>以上三个周期的关系图如下：</p>
<img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E7%90%86%E8%A7%A3%E6%97%B6%E9%92%9F.png" alt="理解时钟" style="zoom:80%;" />
<p>（其中蓝色部分包括了四个机器周期）</p>
<p>而因为时钟信号也是电信号的一种，所以它还兼具了供能的作用，且因电平变化的时间间隔一定，我们甚至可以用时钟来计时。</p>
<p>（PS：经老师纠正，时钟“供能”的说法是错的，时钟并不起供能作用。不过个人认为，从初学者角度来看，这样感性理解问题也不大，只要记得这种说法是不对的即可。）</p>
<h2 id="二-stm32时钟树">二、stm32时钟树</h2>
<p>有了以上的感观认识后，我们先来看看stm32f10x的时钟树：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/stm32%E6%97%B6%E9%92%9F%E6%A0%91.png" alt="stm32时钟树"></p>
<h3 id="2-1-stm32f10x时钟源">2.1、stm32f10x时钟源</h3>
<p>上图蓝色部分标出了stm32的5个时钟源，分别是：</p>
<ul>
<li>HSI：高速内部时钟（High speed internal），由内部RC振荡器产生，频率为8MHz。</li>
<li>HSE：高速外部时钟（High speed external），可外接4-16MHz的晶振作为时钟源。</li>
<li>LSE：低速外部时钟，外接32.768kHz时钟源。</li>
<li>LSI：低速内部时钟，由内部RC振荡器产生，频率为32kHz。</li>
<li>PLL：锁相环倍频输出。可以做到输入时钟的2-16倍的倍频输出。</li>
</ul>
<p>这里把PLL也列为时钟源是参考了诸如野火资料的说法，个人觉得实际的时钟源只能算4个，因为PLL本身只起倍频作用，本身并不能产生时钟频率。当然，这些都是人为定义的东西，不影响使用和对该知识点的理解。</p>
<p>（PS：RC振荡器产生的时钟精度相对较低。）</p>
<h3 id="2-2-系统时钟">2.2、系统时钟</h3>
<p>知道有哪些时钟源后，我们可以发现时钟树是我们熟悉的AHB、APB1、APB2总线。</p>
<p>时钟源与这些外设之间都通过红色部分的<strong>系统时钟SYSCLK</strong>连接在一起，由此观之这个<strong>系统时钟SYSCLK</strong>很重要！！！</p>
<p>既然它辣么重要，我们就先对它分析一波啦！</p>
<p>可以看到，系统时钟有三个输入源：</p>
<ul>
<li>HSI：8MHz</li>
<li>PLLCLK：8-128MHz(因为外接晶振一般为8MHz)</li>
<li>HSE：4-16MHz</li>
</ul>
<p>而SYSCLK可以接受的最大频率是72MHz，这也是后面所有外设可以正常运作的频率。</p>
<p>可以看到，想要达到这个数字，只能通过PLL倍频得到（不止得到，你甚至可以用它超频）。</p>
<p>对了，SYSCLK选择还连着个叫CSS的东西，查下数据手册，得到以下描述：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E6%97%B6%E9%92%9F%E5%AE%89%E5%85%A8%E7%B3%BB%E7%BB%9F.png" alt="时钟安全系统"></p>
<p>可以看到，这东西简单来说就是个报警器。。。帮你检测HSE有没有出问题，有的话就先切到内部时钟源，然后给出相关提示信息。</p>
<p>分析到这里，我们对stm32的时钟树就可以有个相对清晰的认知了。</p>
<p>下面补充一下没有提到的点~~（主要是我没想到其他相对较散的知识点怎么用逻辑串起来）~~：</p>
<ul>
<li>低速内外部时钟应用</li>
<li>MCO时钟输出：用于示波器观察时钟信号，调试所用。</li>
</ul>
<h2 id="三-关于时钟的一些思考">三、关于时钟的一些思考</h2>
<h3 id="3-1-时钟频率">3.1、时钟频率</h3>
<p>从2.1和2.2的讨论中，我们可以发现，系统时钟正常工作的时钟频率是72MHz。但实际输入的系统时钟频率最高到可以到128MHz，最低8MHz，这意味着我们可以不遵循数据手册的规定，做点&quot;违规操作&quot;。</p>
<p>“违规操作”会怎样？由于目前只会点灯，而且LED这哥们对时钟没啥要求。。。基本上改变频率也就是亮灭快慢不同的事，看不出啥，于是我又去现查了下资料：<s>（本菜鸡最近在补数电了 TAT ）</s></p>
<p><a href="https://www.zhihu.com/question/29685396/answer/145507426">时钟频率是个什么概念？？ - 虞己某的回答 - 知乎 </a></p>
<p>从这个回答中，我们大概可出一下结论：</p>
<ul>
<li>频率低了，不能满足设备的频率要求的话，可能无法启动设备。</li>
<li>频率高了，系统稳定性会受影响。具体表现是进行通信的时候，外设可能无法接受到准确的信号。</li>
</ul>
<h3 id="3-2-多个时钟源">3.2、多个时钟源</h3>
<p>刚了解时钟树的时候，我第一反应是——为什么有那么多时钟源？</p>
<p>既然外设都是受系统时钟管理，那么只用一个时钟不是就够了嘛？</p>
<p>基于以上问题，翻阅学习了相关资料，得出了两个最显而易见的结论：</p>
<ul>
<li>多个时钟可以在单个时钟源发生故障时，起到救急的作用。</li>
<li>一个外设有多个时钟源，可以根据需要选择相应频率的时钟源。</li>
</ul>
<h2 id="四-时钟配置分析">四、时钟配置分析</h2>
<p>stm32的时钟树理解后，就是时钟配置问题了。</p>
<p>实际上，当我们创建工程导入启动文件的时候，在main函数开始调用前，启动文件就已经调用了SystemInit函数对系统时钟进行初始化了。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6&amp;%E6%97%B6%E9%92%9F.png" alt="启动文件&amp;时钟"></p>
<p>那为什么还需要做配置分析？直接拿来用不就好了嘛？</p>
<p>我们且不论其它芯片如何，单就看stm32的固件库给我们提供的库函数（下图为system_stm32f10x.c的截图）：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E5%BA%93%E5%87%BD%E6%95%B0%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E8%AE%BE%E7%BD%AE.png" alt="库函数系统时钟设置"></p>
<p>人家ST官方只提供了24MHz，36MHz，48MHz，56MHz，72MHz五种频率的系统时钟设置。</p>
<p>如果项目对时钟有这5种频率外的需求还是得自己动手。基于以上原因，对时钟配置的分析就是刚需了。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/stm32%E6%97%B6%E9%92%9F%E6%A0%91.png" alt="stm32时钟树"></p>
<p>那么，先让我们对着时钟树的图再梳理一遍系统时钟的来龙去脉。</p>
<h4 id="输入源：">输入源：</h4>
<ul>
<li>HSI直接输出，频率只有8MHz。</li>
<li>HSE直接输出，范围4-16MHz，一般为8MHz。</li>
<li>PLL：锁相环倍频输出，倍频范围是2-16倍。且PLL自身有两个输入源：
<ul>
<li>HSI 二分频输出至PLL，这种方式的系统时钟最高可至64MHz。</li>
<li>HSE直接输出至PLL。</li>
</ul>
</li>
</ul>
<h4 id="输出源：">输出源：</h4>
<ul>
<li>直接输出。</li>
<li>输出至AHB总线，经预分频器可做 1~512 分频。</li>
<li>AHB总线预分频后，经低速外设总线APB1和高速总线APB2。</li>
</ul>
<p>因为考虑到功耗的问题，外设只有用到的时候才会开启时钟，所以SYSCLK只需要初始化总线时钟即可。</p>
<p>基于这个原因，对于系统时钟配置的流程大概可以总结为以下步骤：</p>
<ol>
<li>选择并开启时钟源（使用PLL作为系统时钟源还需要选择倍频）。</li>
<li>选择APB1、APB2的预分频。</li>
<li>选择AHB预分频。</li>
</ol>
<p>为什么不是照着图从左到右的顺序配置？</p>
<p>答：如果AHB先开启，而APB1、APB2未设置的话会出现紊乱。<s>（看完源码后推测的）</s></p>
<p>下面以库函数 **SetSysClockTo72()**为示例，搭配数据手册学习配置过程，先把源码贴上：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetSysClockTo72</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> StartUpCounter = <span class="number">0</span>, HSEStatus = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/</span>    </span><br><span class="line">  <span class="comment">/* Enable HSE */</span>    </span><br><span class="line">  RCC-&gt;CR |= ((<span class="keyword">uint32_t</span>)RCC_CR_HSEON);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Wait till HSE is ready and if Time out is reached exit */</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    HSEStatus = RCC-&gt;CR &amp; RCC_CR_HSERDY;</span><br><span class="line">    StartUpCounter++;  </span><br><span class="line">  &#125; <span class="keyword">while</span>((HSEStatus == <span class="number">0</span>) &amp;&amp; (StartUpCounter != HSE_STARTUP_TIMEOUT));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((RCC-&gt;CR &amp; RCC_CR_HSERDY) != RESET)</span><br><span class="line">  &#123;</span><br><span class="line">    HSEStatus = (<span class="keyword">uint32_t</span>)<span class="number">0x01</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    HSEStatus = (<span class="keyword">uint32_t</span>)<span class="number">0x00</span>;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HSEStatus == (<span class="keyword">uint32_t</span>)<span class="number">0x01</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Enable Prefetch Buffer */</span></span><br><span class="line">    FLASH-&gt;ACR |= FLASH_ACR_PRFTBE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flash 2 wait state */</span></span><br><span class="line">    FLASH-&gt;ACR &amp;= (<span class="keyword">uint32_t</span>)((<span class="keyword">uint32_t</span>)~FLASH_ACR_LATENCY);</span><br><span class="line">    FLASH-&gt;ACR |= (<span class="keyword">uint32_t</span>)FLASH_ACR_LATENCY_2;    </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* HCLK = SYSCLK */</span></span><br><span class="line">    RCC-&gt;CFGR |= (<span class="keyword">uint32_t</span>)RCC_CFGR_HPRE_DIV1;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* PCLK2 = HCLK */</span></span><br><span class="line">    RCC-&gt;CFGR |= (<span class="keyword">uint32_t</span>)RCC_CFGR_PPRE2_DIV1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* PCLK1 = HCLK */</span></span><br><span class="line">    RCC-&gt;CFGR |= (<span class="keyword">uint32_t</span>)RCC_CFGR_PPRE1_DIV2;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> STM32F10X_CL</span></span><br><span class="line">    <span class="comment">/* Configure PLLs ------------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */</span></span><br><span class="line">    <span class="comment">/* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */</span></span><br><span class="line">        </span><br><span class="line">    RCC-&gt;CFGR2 &amp;= (<span class="keyword">uint32_t</span>)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |</span><br><span class="line">                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);</span><br><span class="line">    RCC-&gt;CFGR2 |= (<span class="keyword">uint32_t</span>)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |</span><br><span class="line">                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Enable PLL2 */</span></span><br><span class="line">    RCC-&gt;CR |= RCC_CR_PLL2ON;</span><br><span class="line">    <span class="comment">/* Wait till PLL2 is ready */</span></span><br><span class="line">    <span class="keyword">while</span>((RCC-&gt;CR &amp; RCC_CR_PLL2RDY) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">/* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */</span> </span><br><span class="line">    RCC-&gt;CFGR &amp;= (<span class="keyword">uint32_t</span>)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);</span><br><span class="line">    RCC-&gt;CFGR |= (<span class="keyword">uint32_t</span>)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | </span><br><span class="line">                            RCC_CFGR_PLLMULL9); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>    </span></span><br><span class="line">    <span class="comment">/*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */</span></span><br><span class="line">    RCC-&gt;CFGR &amp;= (<span class="keyword">uint32_t</span>)((<span class="keyword">uint32_t</span>)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |</span><br><span class="line">                                        RCC_CFGR_PLLMULL));</span><br><span class="line">    RCC-&gt;CFGR |= (<span class="keyword">uint32_t</span>)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* STM32F10X_CL */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Enable PLL */</span></span><br><span class="line">    RCC-&gt;CR |= RCC_CR_PLLON;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait till PLL is ready */</span></span><br><span class="line">    <span class="keyword">while</span>((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Select PLL as system clock source */</span></span><br><span class="line">    RCC-&gt;CFGR &amp;= (<span class="keyword">uint32_t</span>)((<span class="keyword">uint32_t</span>)~(RCC_CFGR_SW));</span><br><span class="line">    RCC-&gt;CFGR |= (<span class="keyword">uint32_t</span>)RCC_CFGR_SW_PLL;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait till PLL is used as system clock source */</span></span><br><span class="line">    <span class="keyword">while</span> ((RCC-&gt;CFGR &amp; (<span class="keyword">uint32_t</span>)RCC_CFGR_SWS) != (<span class="keyword">uint32_t</span>)<span class="number">0x08</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123; <span class="comment">/* If HSE fails to start-up, the application will have wrong clock </span></span><br><span class="line"><span class="comment">         configuration. User can add here some code to deal with this error */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一眼看上去很长，寄存器也很多，但是米有关系。先把出现的寄存器记下来：</p>
<ul>
<li>RCC-&gt;CR</li>
<li>RCC-&gt;CFGR</li>
<li>RCC-&gt;CFGR2</li>
<li>FLASH-&gt;ACR</li>
</ul>
<p>然后干嘛？当然是去查查手册这些寄存器是干嘛用的呀！由于还是小萌新阶段，只需要了解上面每个寄存器大概的作用结合源码学习即可，手册暂时不必深究。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/RCC_CR.png" alt="RCC_CR"></p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/RCC_CFGR.png" alt="RCC_CFGR"></p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/FLASH_ACR.png" alt="FLASH_ACR"></p>
<p>结合以上认识，下面我们来一段一段分析源码：</p>
<h3 id="1-开始hse时钟">1、开始HSE时钟</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/</span>    </span><br><span class="line">  <span class="comment">/* Enable HSE */</span>    </span><br><span class="line">  RCC-&gt;CR |= ((<span class="keyword">uint32_t</span>)RCC_CR_HSEON);<span class="comment">//HSEON -&gt; HSE_ON</span></span><br></pre></td></tr></table></figure>
<h3 id="2-等待hse就绪">2、等待HSE就绪</h3>
<p>如果在一定时间内等不到就退出作异常处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/* Wait till HSE is ready and if Time out is reached exit */</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    HSEStatus = RCC-&gt;CR &amp; RCC_CR_HSERDY;<span class="comment">//HSERDY -&gt; HSE_Ready</span></span><br><span class="line">    StartUpCounter++;  </span><br><span class="line">  &#125; <span class="keyword">while</span>((HSEStatus == <span class="number">0</span>) &amp;&amp; (StartUpCounter != HSE_STARTUP_TIMEOUT));</span><br><span class="line"><span class="comment">/** HSE如果就绪，HSEStatus = 1 **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 如果HSE_Ready = RESET，即:HSE没有准备就绪 **/</span></span><br><span class="line">  <span class="keyword">if</span> ((RCC-&gt;CR &amp; RCC_CR_HSERDY) != RESET)</span><br><span class="line">  &#123;</span><br><span class="line">    HSEStatus = (<span class="keyword">uint32_t</span>)<span class="number">0x01</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    HSEStatus = (<span class="keyword">uint32_t</span>)<span class="number">0x00</span>;</span><br><span class="line">  &#125;  </span><br></pre></td></tr></table></figure>
<h3 id="3-hse状态正常就继续-异常就立刻处理">3、HSE状态正常就继续，异常就立刻处理</h3>
<p>状态异常的话，经条件语句跳转到下图的模块处理异常。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/HSE%E7%8A%B6%E6%80%81%E5%88%A4%E6%96%AD.png" alt="HSE状态判断"></p>
<h4 id="3-1-hse状态正常情况分析">3.1、HSE状态正常情况分析</h4>
<h5 id="3-1-1-等待机器取指令">3.1.1、等待机器取指令</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Enable Prefetch Buffer */</span></span><br><span class="line">FLASH-&gt;ACR |= FLASH_ACR_PRFTBE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Flash 2 wait state */</span></span><br><span class="line">FLASH-&gt;ACR &amp;= (<span class="keyword">uint32_t</span>)((<span class="keyword">uint32_t</span>)~FLASH_ACR_LATENCY);</span><br><span class="line">FLASH-&gt;ACR |= (<span class="keyword">uint32_t</span>)FLASH_ACR_LATENCY_2;</span><br></pre></td></tr></table></figure>
<h5 id="3-1-2-设置ahb-ap1-ap2的预分频因子">3.1.2、设置AHB、AP1、AP2的预分频因子</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* HCLK = SYSCLK */</span></span><br><span class="line">RCC-&gt;CFGR |= (<span class="keyword">uint32_t</span>)RCC_CFGR_HPRE_DIV1;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* PCLK2 = HCLK */</span></span><br><span class="line">RCC-&gt;CFGR |= (<span class="keyword">uint32_t</span>)RCC_CFGR_PPRE2_DIV1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* PCLK1 = HCLK */</span></span><br><span class="line">RCC-&gt;CFGR |= (<span class="keyword">uint32_t</span>)RCC_CFGR_PPRE1_DIV2;</span><br></pre></td></tr></table></figure>
<h5 id="3-1-3-选择pll的时钟源">3.1.3、选择PLL的时钟源</h5>
<p>源码里这段其实还有二三十行代码，不过那是互联型芯片的配置代码，这里f103是基础型，所以先暂时略过不看。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */</span></span><br><span class="line">   RCC-&gt;CFGR &amp;= (<span class="keyword">uint32_t</span>)((<span class="keyword">uint32_t</span>)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |</span><br><span class="line">                                       RCC_CFGR_PLLMULL));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*		HSE 与上 PLLMULL9 做到 72MHz的系统时钟输出		*/</span></span><br><span class="line">   RCC-&gt;CFGR |= (<span class="keyword">uint32_t</span>)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);</span><br></pre></td></tr></table></figure>
<h5 id="3-1-4-开启pll时钟并等待就绪">3.1.4、开启PLL时钟并等待就绪</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Enable PLL */</span></span><br><span class="line">    RCC-&gt;CR |= RCC_CR_PLLON;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait till PLL is ready */</span></span><br><span class="line">    <span class="keyword">while</span>((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-1-5-选择pll作为系统时钟源">3.1.5、选择PLL作为系统时钟源</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Select PLL as system clock source */</span></span><br><span class="line">   RCC-&gt;CFGR &amp;= (<span class="keyword">uint32_t</span>)((<span class="keyword">uint32_t</span>)~(RCC_CFGR_SW));</span><br><span class="line">   RCC-&gt;CFGR |= (<span class="keyword">uint32_t</span>)RCC_CFGR_SW_PLL;    </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Wait till PLL is used as system clock source */</span></span><br><span class="line">   <span class="keyword">while</span> ((RCC-&gt;CFGR &amp; (<span class="keyword">uint32_t</span>)RCC_CFGR_SWS) != (<span class="keyword">uint32_t</span>)<span class="number">0x08</span>)</span><br><span class="line">   &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>以上。</p>
<h2 id="五-总结">五、总结</h2>
<h3 id="5-1-配置时钟的流程">5.1、配置时钟的流程</h3>
<ul>
<li>开启时钟并等待就绪</li>
<li>若时钟开启异常就退出（可做相关异常处理）</li>
<li>开启正常，先配置相关总线的预分频因子</li>
<li>最后选择系统时钟，让外设得到能源供应</li>
</ul>
<h3 id="5-2-学习一款mcu的时钟流程">5.2、学习一款MCU的时钟流程</h3>
<ul>
<li>看时钟树——分析时钟源的来龙去脉</li>
<li>查数据手册，找到以下问题的答案：
<ul>
<li>时钟源怎么开启？</li>
<li>相关外设的时钟怎么控制？</li>
<li>系统时钟源怎么选择？</li>
</ul>
</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.zhihu.com/question/29685396/answer/145507426">时钟频率是个什么概念？？ - 虞己某的回答 - 知乎 </a></li>
<li><a href="https://zhuanlan.zhihu.com/p/97987044">【心得篇】指令周期、机器周期和时钟周期</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/77053601">初涉STM32之浅谈时钟使能问题 — 理解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/250022175">一篇文章，彻底搞懂单片机时钟架构！</a></li>
<li><a href="https://blog.csdn.net/bulebin/article/details/73433677">STM32时钟树分析</a></li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>MCU</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>【初入电子坑之stm32篇（三）】位带操作</title>
    <url>/2021/01/16/Embedded/MCU/stm32/%E3%80%90%E5%88%9D%E5%85%A5%E7%94%B5%E5%AD%90%E5%9D%91%E4%B9%8Bstm32%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%91%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>由寄存器编程我们可以知道，很多时候我们需要修改的值的其实只有单独的某一位，那在stm32中怎么实现对单独一个位的操作呢？位带操作！</p>
</blockquote>
<a id="more"></a>
<h3 id="问题讨论范围">问题讨论范围</h3>
<ul>
<li>什么是位带操作？</li>
<li>位带操作有什么意义？</li>
<li>怎么进行位带操作？</li>
</ul>
<h2 id="正文">正文</h2>
<h3 id="位带操作">位带操作</h3>
<p>位带操作(也叫位段操作)，可以理解为允许进行位操作的地带。</p>
<p>由于底层电路设计的原因，stm32单片机单次可操作的存储单元是4Byte，所以想要进行位操作的话从逻辑上是行不通的。但是ST公司考虑到了这种用户需求，在内存地址映射表中专门留出了一块地址。这块地址就被称为了<strong>位带别名区</strong>。</p>
<p><strong>位带别名区</strong> 的作用很简单，它其实就是在内存映射表的基础上做了二次映射。</p>
<p>既然你stm32单次操作最少只能控制4个Byte，那么我们把1Bit当4Byte使用，其中只有最低位的1个Bit操作有效不就可以了嘛。</p>
<p>但不是所有内存地址都支持位带操作的，所以支持位带操作的内存地址也就被称为了<strong>位带区</strong>。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E4%BD%8D%E5%B8%A6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="位带示意图"></p>
<p>上图就是支持位带操作的区域示意图，蓝色和紫色的箭头指向就是位带区上的每一位进行二次映射后的内存地址区域。</p>
<p>我们对比下外设的地址映射表：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E5%86%85%E5%AD%98%E8%B5%B7%E5%A7%8B%E4%BD%8D%E7%BD%AE.png" alt="内存起始位置"></p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E5%86%85%E5%AD%98%E6%9C%AB%E4%BD%8D%E7%BD%AE.png" alt="内存末位置"></p>
<p>可以看到所有片上外设的地址都包含在内了。所以我们操作外设的时候都可以进行位带操作。</p>
<h3 id="位带操作的意义">位带操作的意义</h3>
<p>一开始看位带操作的时候，有种鸡肋的感觉。</p>
<p>原因有二：</p>
<ul>
<li>腾出远多于实际需要操作的外设、SRAM内存，只为了可以单独操作极少部分内存的一个bit，这值得吗？</li>
<li>官方既然给出了固件库库函数可以对单独的某一位进行修改，为什么又还需要用位带操作？</li>
</ul>
<p>在查阅了很多资料后，得出了一个勉强可以说服自己的答案：</p>
<blockquote>
<p>固件库的本质是调用已经封装好的函数，而函数的运行效率比寄存器操作要慢。</p>
<p>而直接使用寄存器操作的话，会有些不便、容易出错，所以位带操作就是这两者中的折中方案了。</p>
</blockquote>
<p>我也不知道这个答案对不对，为了可能需要节省的性能而专门腾出辣么多内存干这件事真的值得吗？也许是我太菜还没不能理解它的珍贵之处吧。</p>
<hr>
<p>2021年4月22日更新：</p>
<p>经网友提醒，之前说腾出辣么多内存的说法有失严谨，因为内存地址映射表中的内存不是实际的物理内存，而是CPU能控制的内存范围。从汇编的学习中，我们可以知道CPU可以控制的内存范围是有限的，所以我还是不能理解腾出了辣么多内存的意义。。。有那么多内存预算干点别的不香嘛。。。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>MCU</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>【初入电子坑之stm32篇（二）】固件库编程</title>
    <url>/2021/01/16/Embedded/MCU/stm32/%E3%80%90%E5%88%9D%E5%85%A5%E7%94%B5%E5%AD%90%E5%9D%91%E4%B9%8Bstm32%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%91%E5%9B%BA%E4%BB%B6%E5%BA%93%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>在<a href="https://zhuanlan.zhihu.com/p/344913189">【初入电子坑之stm32篇（一）】初识stm32与寄存器编程</a>中可以看到，寄存器编程虽然消耗CPU性能少、速度快。但于我们开发应用来说，那就是刀耕火种中的刀耕火种。。。</p>
<p>芯片厂家也考虑到了这点，所以一般会提供一些基本的固件库供开发人员使用。stm32的爸爸ST公司自然也不例外。</p>
</blockquote>
<a id="more"></a>
<h2 id="cmsis标准">CMSIS标准</h2>
<p>一种内核架构通常会被多家芯片厂家采用，而芯片厂家对于芯片内部的外设布置是有差异的，这就很容易导致软件在同内核，不同外设的芯片上移植困难。</p>
<p>为了解决这个问题，设计架构的公司和使用架构的芯片厂商间就会制定一个标准，让软件可以适配同内核不同外设的芯片的情况。</p>
<p>而CMSIS标准(Cortex MicroController Software Interface Standard) 就是 ARM 与芯片厂商建立的一种标准实例。</p>
<p>CMSIS标准其实是一个软件抽象层。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB.png" alt="层次关系"></p>
<p>（上图中，黄色部分是MCU硬件层面的东西，蓝色CMSIS层其实就是程序。）</p>
<p>它的内容有两个方面：</p>
<ul>
<li>内核函数层：内核寄存器的名字、地址定义。由ARM公司提供。</li>
<li>设备外设层：片上核外外设的地址和中断定义。有芯片生产商负责。</li>
</ul>
<h2 id="初识stm32固件库">初识stm32固件库</h2>
<p>了解了CMSIS标准后，我们就可以很愉快的去stm32提供的官方固件库找我们要的东西了。</p>
<p>打开固件库文件夹我们可以看到有以下两个文件夹：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E5%88%9D%E8%AF%86%E5%9B%BA%E4%BB%B6%E5%BA%93.png" alt="初识固件库"></p>
<p>从文件名就可以盲猜，一个是CMSIS标准相关的配置文件夹，一个是相对具体型号的芯片外设配置文件夹。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/CMSIS.png" alt="CMSIS"><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/CM3.png" alt="CM3"></p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E5%86%85%E6%A0%B8%E5%AF%84%E5%AD%98%E5%99%A8%E6%98%A0%E5%B0%84%E7%9B%B8%E5%85%B3.png" alt="内核寄存器映射相关" style="zoom:50%;" /><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E6%97%B6%E9%92%9F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="时钟配置文件" style="zoom:50%;" /></p>
<p>点进CMSIS可以发现，不出所料，就是内核的配置相关配置的源文件、stm3210x的时钟配置文件还有启动文件。</p>
<p>我们用的时候把它们复制到我们自己的工程里即可。</p>
<p>然后去隔壁 STM32F10x_StdPeriph_Driver 文件夹瞄瞄，这个就很简单粗暴了，一个inc（include）、一个src（source）。</p>
<img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E5%A4%96%E8%AE%BE%E6%96%87%E4%BB%B6.png" alt="外设文件" style="zoom:50%;" />
<p>随便点进去就会发现ST官方按照不同的外设模块，stm32f10x_xxx.c的方式给分门别类的放好了。（见下图）</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E5%9B%BA%E4%BB%B6%E5%BA%93%E5%91%BD%E5%90%8D.png" alt="固件库命名"></p>
<p>既然东西齐活了，下面就可以先愉快的建个固件库工程模板，然后正式开启固件库编程之旅了~~~</p>
<p>（创建固件库工程方法，请移步以下链接：</p>
<p><a href="https://zhuanlan.zhihu.com/p/367054113">【初入电子坑之stm32篇（补充1）】新建固件库工程</a></p>
<h2 id="stm32固件库编程">stm32固件库编程</h2>
<p>下面结合实例叙述固件库的编程方式。</p>
<h3 id="实例：按键控制led">实例：按键控制LED</h3>
<p>首先，让我们回忆一下，点灯的流程：</p>
<ul>
<li>开始GPIO口时钟使能</li>
<li>初始化GPIO
<ul>
<li>选择引脚IO口引脚</li>
<li>并选择需要的IO模式</li>
</ul>
</li>
<li>设置对应IO口的位值</li>
</ul>
<p>如果有按键开关的话就是，就加上以下流程：</p>
<ul>
<li>判断读取开关对应IO口的值（IDR寄存器里）</li>
<li>根据判断情况做相应的动作</li>
</ul>
<h3 id="库函数运用">库函数运用</h3>
<p>上述流程动作，固件库全都是给我们安排得妥妥，直接调用相关函数就可以了。</p>
<p>具体的相关函数都在对应外设的头文件最下面，如我们即将使用的GPIO:</p>
<img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/gpio%E5%A4%B4%E6%96%87%E4%BB%B6.png" alt="gpio头文件" style="zoom:80%;" />
<img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E5%85%B7%E4%BD%93%E5%87%BD%E6%95%B0%E6%BC%94%E7%A4%BA.png" alt="具体函数演示" style="zoom:80%;" />
<p>从上面两图可以看到：</p>
<ul>
<li>想要什么基本操作？去对应外设的库头文件找啊！</li>
<li>函数参数怎么用？直接去找源码看定义啊！</li>
<li>不知道函数功能是啥？直接看源码注释啊，官方写得老详细了。。。</li>
</ul>
<p>具体代码在本人github的study record库里。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>MCU</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>【初入电子坑之stm32篇（补充1）】新建固件库工程</title>
    <url>/2021/01/11/Embedded/MCU/stm32/%E3%80%90%E5%88%9D%E5%85%A5%E7%94%B5%E5%AD%90%E5%9D%91%E4%B9%8Bstm32%E7%AF%87%EF%BC%88%E8%A1%A5%E5%85%851%EF%BC%89%E3%80%91%E6%96%B0%E5%BB%BA%E5%9B%BA%E4%BB%B6%E5%BA%93%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>新建基于固件库的工程，不理清构建流程的话，看上去还是有点繁琐的，在此记录一下。</p>
</blockquote>
<a id="more"></a>
<h2 id="原理">原理</h2>
<p>为了做到心中有数，我们先要搞清楚为什么这么干。</p>
<p>首先，我们知道，所谓的固件库编程，就是ST公司为了提高广大开发者的开发效率从而提供给大家的一套驱动程序。</p>
<p>我们在工程中想要使用这套程序自然就要先从官方提供的资料中把我们需要的源码copy到自己的工程中去。而又因为这些源码文件有点多，所以为了后面的维护考虑，我们要对这些文件进行分类。</p>
<p>上面虽然啰嗦了很多，但是说白了，新建固件库工程的过程——就是库文件导入和文件管理的过程。</p>
<h2 id="示例">示例</h2>
<p>在明白了上述原理之后，经过参考正点原子和野火的工程构建方式。得出以下个人觉得比较舒服的工程管理方式(仅供参考)：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/20210309052812.png" alt="工程文件管理"></p>
<ul>
<li>Readme：	工程整体性说明文档</li>
<li>Libraries：   工程所需的官方启动文件、固件库文件等</li>
<li>Output：      工程输出的如：hex之类的文件</li>
<li>Project：       keil自动生成文件</li>
<li>User：           自己写的相关工程源码</li>
</ul>
<p>对应的在IDE中，我们可以对源文件进行分组：</p>
<img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/20210309052837.png" alt="IDE源文件组管理" style="zoom:67%;" />
<p>需要注意的是，这里的源文件管理和整个工程的文件管理并不完全一致！！！</p>
<p>IDE的源文件分组，在添加源文件时，文件路径需要精确到源文件所在的当前文件夹。</p>
<p>举个栗子：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/20210309052853.png" alt="举例1"></p>
<p>Libraries中包含这两个文件夹 CMSIS 和 STM32F10x_StdPeriph_Driver。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/20210309052954.png" alt="举例2" style="zoom:67%;" /><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/20210309053005.png" alt="举例3" style="zoom:50%;" /></p>
<p>而源文件在 CMSIS 和 STM32F10x_StdPeriph_Driver/src中，所以我们需要添加的是这两个文件。</p>
<p>到这里，工程建立算是初步创建完成了。</p>
<h3 id="小结">小结</h3>
<ul>
<li>
<p>根据自己喜欢的方式，合理对工程文件进行分类。</p>
</li>
<li>
<p>工程文件夹与IDE源文件分组并不完全一致。</p>
</li>
</ul>
<h2 id="重点">重点！！！</h2>
<h3 id="1-路径设置">1、路径设置</h3>
<p>上面的示例，只是人为的文件管理方式，IDE是不知道的。换句话说，如果这个时候你想直接调用库，IDE都不知道去哪找头文件。</p>
<p>所以，文件怎么归类管理都可以，但分类完后得告诉IDE这些文件在哪。</p>
<p>对于KeilL来说，打开option找到C/C++选项，找到Include Paths，然后所有工程.h文件所在文件夹路径加上去即可。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9.png" alt="路径选择" style="zoom:67%;" /><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A92.png" alt="路径选择2" style="zoom:67%;" /></p>
<p>你以为这样就完了？还没呢！！！</p>
<h3 id="2-conf条件编译">2、conf条件编译</h3>
<p>在<a href="https://zhuanlan.zhihu.com/p/344916337">【初入电子坑之stm32篇（二）】固件库编程</a> 中，我们已经讨论过了诸如 “stm32f10x_conf.h” 这样缝合怪文件，它把所有外设的头文件都包在里面了，极大的简化了我们的代码。但它在官方提供源码中是这样的：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E7%BC%9D%E5%90%88%E6%80%AA.png" alt="缝合怪"></p>
<p>调用它需要我们定义一个名为 <strong>USE_STDPERIPH_DRIVER</strong> 的宏。</p>
<p>所以想要用它，有三种选择：</p>
<ul>
<li>找个位置，老老实实把这个宏定义了</li>
<li>直接把条件编译的语句注释掉</li>
<li>使用Keil软件的宏定义模板</li>
</ul>
<p>这里简单说下keil的宏定义模板。因为只要在这个模板上写好了，以后其它工程只要还需要类似的配置，我们就不需要重新找地方做宏定义or注释条件编译了。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E5%AE%8F%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF.png" alt="宏定义模板"></p>
<p>如上图，还是在option中找到C/C++选项，然后在Define中写入即可。若要进行多个宏定义，中间用逗号隔开。</p>
<h3 id="3-启动文件选择宏定义">3、启动文件选择宏定义</h3>
<p>最后，是关于启动文件选择的问题。</p>
<p>我们知道stm32因为flash的容量大小，不同分成了很多个不同的启动文件。而固件库为了适配不同型号的芯片，做了如下操作：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E5%AE%8F%E5%AE%9A%E4%B9%89.png" alt="启动文件宏定义"></p>
<p>条边编译+注释。我们需要用时只要解除对应的宏定义项的注释即可。但每次操作库文件容易存在容易出错、调试不便等问题。所以官方也做了相关的tip——使用软件的宏定义模板。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E5%AE%8F%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF.png" alt="宏定义模板"></p>
<p>如上图。</p>
<h2 id="总结">总结</h2>
<p>创建工程遵从以下步骤：</p>
<ol>
<li>合理对应工程文件夹分类</li>
<li>在IDE中，进一步进行详细的源文件分组</li>
<li>头文件路径设置</li>
<li>如果是第一次做此型号的32芯片配置，可能还需要配置
<ol>
<li>固件库配置集合的宏定义</li>
<li>启动文件选择的宏定义</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>MCU</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>【初入电子坑之stm32篇（一）】初识stm32与寄存器编程</title>
    <url>/2021/01/04/Embedded/MCU/stm32/%E3%80%90%E5%88%9D%E5%85%A5%E7%94%B5%E5%AD%90%E5%9D%91%E4%B9%8Bstm32%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%91%E5%88%9D%E8%AF%86stm32%E4%B8%8E%E5%AF%84%E5%AD%98%E5%99%A8%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>以下为本人基于野火stm32F103EVT6开发板学习stm32的学习笔记。</p>
</blockquote>
<a id="more"></a>
<h2 id="导图概览">导图概览</h2>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E5%88%9D%E8%AF%86stm32%E6%A6%82%E8%A7%88.png" alt="初识stm32概览"></p>
<h2 id="初识32">初识32</h2>
<h3 id="1-下载方式">1、下载方式</h3>
<p>把单片机耍起来，除了要写程序外，当然还得把程序下载到单片机的上啦！而单片机一般有以下两种下载程序方式：</p>
<ul>
<li>仿真器下载</li>
<li>ISP下载</li>
</ul>
<p>曾经玩过简单玩过一下下51和arduino。这两个硬件平台玩的时候都对下载方式进行了一定的简化，所以直到现在我才知道下载方式也是有讲究的orz。</p>
<h4 id="仿真器下载">仿真器下载</h4>
<p>所谓仿真器下载就是，下载程序的时候，在片外连接一个叫仿真器的东西。连上这个东西之后可以实时烧录程序观察板子的现象，无需按reset按键，并可以单步跟踪调试观察实时现象（跟写纯软件的单步调试是一个意思）。</p>
<p>虽然目前木有入手仿真器，不过以前简单玩过的板子内集成了仿真器的功能，所以也算体验过了。</p>
<h4 id="isp下载">ISP下载</h4>
<p>全称：In-System Programmability，即：在系统可编程。</p>
<p>一开始我看到这名字的时候有点蒙蔽，ISP下载？啥玩意儿，网络运营商下载？查过资料才知道，在很久很久之前~~~老前辈们烧录程序时居然还要把芯片取下来，拿到专门烧录程序的机器上烧录程序，然后再插会电路板上，十分麻烦。而ISP下载，就是现在习以为常的在板上插根线，直接连接电脑烧录程序的方式。</p>
<p>在目前“以实现功能为主，不深究具体实现。”的学习思想指导下，对于这东西，没啥需要注意的。了解一下，表达下对前辈们的敬意即可。</p>
<p>在这里有个小建议：<strong>在缺乏相关电路知识的情况下，不建议头铁的去研究ISP电路实现，那么做的话就有点偏离我们现在的主要目的了。</strong></p>
<h3 id="2-芯片选型">2、芯片选型</h3>
<p>即使是同一款芯片,也有很多不同的型号。它们的差别体现在引脚数、晶振频率、flash、可用外设的差别上，虽然对于个人学习、实验来说只要功能相对够齐全一般都没啥问题。但在DIY项目、工业生产上，每bit都要尽量抠着用。（多一毛钱，乘于1w、100w都是好多好多钱啊！！！）</p>
<p>所以简单了解下，还是很有必要的。</p>
<p>对了，上面提到的“引脚”，可以简单理解为黑黑的芯片周围那很多根的白色金属。</p>
<h4 id="stm32命名规则">stm32命名规则</h4>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/stm32%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99.png" alt="stm32命名规则"></p>
<p>7部分：</p>
<ul>
<li>STM32：ST公司生产的Cortex-M内核的32位微控制器</li>
<li>F：芯片的基础型子系列。还有其他的诸如：S标准型、L超低功耗等。</li>
<li>103：跟上面类似。</li>
<li>V：引脚数代号，V表示100引脚。</li>
<li>E：flash大小代号，E表示512KB。</li>
<li>T：芯片封装种类。</li>
<li>6：芯片适应温度等级。</li>
</ul>
<p>以上信息做到大概了解即可。有具体需求时，看官方的选型手册即可。</p>
<h3 id="3-系统结构">3、系统结构</h3>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/stm32%E8%8A%AF%E7%89%87%E6%9E%B6%E6%9E%84.png" alt="stm32芯片架构"></p>
<p>上图为stm32的芯片架构简图。其中大概可以分由ARM公司设计的Cortex-M3内核，和由ST公司以Cortex-M3内核为基础设计的“外围结构”。（这里所指的外围，是相对于内核而言的。）</p>
<p>而可以进行的绝大部分操作，都集中在外设的寄存器上，通过操作外设寄存器的值，从而控制芯片I/O引脚的输入输出，从而来完成我们需要的操作。</p>
<p>关于更多的寄存器的相关知识，可参考我的汇编学习笔记：</p>
<a href="#">Post not found: 汇编语言(一)基础知识与寄存器 汇编语言(一)基础知识与寄存器</a>
<p>（还没填完坑。。。）</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/stm32%E7%B3%BB%E7%BB%9F%E6%A1%86%E5%9B%BE.png" alt="stm32系统框图"></p>
<p>上图为stm32的系统结构框图，其中AHB系统总线（蓝色方框4那）连接着外设。换句话说，我们可以通过AHB总线，进行最大限度的自由发挥，是可以为所欲为的地方。</p>
<p>AHB通过桥接的方式分出APB1、APB2两条外设总线，它们分别挂载着一些外设，其中APB1的访问速率比APB2慢一倍。（PS：为什么会慢一倍，在后面《理解时钟系统》中会解释，别钻牛角尖哈。。。）</p>
<p>在ST公司的《STM32F10x-中文参考手册》，我们可以找到AHB的存储器映射地址表，如下图：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/AHB%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84.png" alt="AHB地址映射"></p>
<p>通过这个表，我们可以找到所有外设寄存器的地址，设计程序改变相关寄存器的值，从而完成我们想要的控制。</p>
<h2 id="入门运用">入门运用</h2>
<h3 id="0-启动文件">0、启动文件</h3>
<p>所有单片机都有这么一个东西，从运用的角度来看，我们无需深究它，只需对它的作用有个大概的感性认知即可。它的作用如下：</p>
<ul>
<li>在单片机上电之后，使用汇编指令对内核进行一些必要的初始化。</li>
<li>利用汇编指令在stm32芯片上搭建了一个c语言的运行环境。</li>
</ul>
<p>（如果你想深挖这大哥的大概运用原理，这边建议你去刷一遍刘爽的《汇编语言》）</p>
<h3 id="1-gpio">1、GPIO</h3>
<h4 id="简介">简介</h4>
<p><strong>GPIO</strong>（英语：General-purpose input/output），功能类似8051的P0—P3。不同的是，这哥们比较高级，下面放张它的结构图，让大家感受下它的“高级”：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/GPIO%E7%AB%AF%E5%8F%A3%E7%BB%93%E6%9E%84.png" alt="GPIO端口结构"></p>
<p>在51里，P0——P3的引脚我们可以直接修改它们对应的输出数据寄存器的值从而控制I/O口的输出。但从上图我们可以看到，进行同样的操作，用GPIO我们需要操作多个寄存器，才可以修改输出数据寄存器ODR内的数据。</p>
<p>当然啦，既然操作相对繁琐辣么多，必然有它的意义所在——这哥们有8个输入/输出模式：</p>
<h5 id="输入：">输入：</h5>
<ul>
<li>输入浮空</li>
<li>输入上拉</li>
<li>输入下拉</li>
<li>模拟输入</li>
</ul>
<h5 id="输出：">输出：</h5>
<ul>
<li>开漏输出</li>
<li>推挽输出</li>
<li>开漏复用功能</li>
<li>推挽复用功能</li>
</ul>
<p>我曾经很舍本逐末的探究了上面几种输入输出模式背后的原理，然鹅。。。发现由于认知层面的缺失，即使勉强研究明白了几分，也没什么卵用。。。</p>
<p>所以还是先把它用起来吧，其他的以后再说。。。</p>
<h4 id="控制流程">控制流程</h4>
<p>想要令GPIO的I/O口输入/输出值，要进行以下流程：</p>
<ol>
<li>开启对应端口的时钟使能端（为了节省功耗，外设的使能默认关闭。时钟使能可简单理解为是一个控制开关）</li>
<li>选择引脚，并配置对应的IO模式、若是输出模式还需选择输出速率。</li>
<li>控制端口寄存器CRL/CRH清零</li>
<li>两种情况：
<ol>
<li>输出模式：设置引脚(即：数据输出/输入寄存器ODR)的值</li>
<li>输入模式：读取引脚对应引脚信息，以便加以利用（如开关）</li>
</ol>
</li>
</ol>
<p>由以上对GPIO的认知，我们可以引申出两种在stm32上不同的编程方式：</p>
<ul>
<li>基于寄存器编程</li>
<li>基于固件库编程</li>
</ul>
<p>下面以点亮LED灯为例，进行分析。</p>
<h3 id="2-基于寄存器编程">2、基于寄存器编程</h3>
<p>基于寄存器编程其实又可以叫<strong>基于数据手册编程</strong>，因为它很简单粗暴。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/%E9%87%8E%E7%81%ABLED%E6%A8%A1%E5%9D%97.png" alt="野火LED模块"></p>
<p>上面是野火指南者开发板的LED原理图。可以看到这是个三原色LED灯，通过PB1、PB0、PB5端口输出低电平就可以让LED发出对应的灯光颜色。</p>
<p>根据上一小节中，我们分析控制GPIO端口的流程。我们先从官方的数据手册分别找出对应的寄存器地址。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/RCC%E5%9F%BA%E5%9C%B0%E5%9D%80.png" alt="RCC基地址"></p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/APB2%E4%BD%BF%E8%83%BD%E6%8E%A7%E5%88%B6%E5%9C%B0%E5%9D%80.png" alt="APB2使能控制地址"></p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/GPIOB%E5%9F%BA%E5%9C%B0%E5%9D%80.png" alt="GPIOB基地址"></p>
<p>从而得出Level1版的点灯程序：</p>
<h4 id="level-1：无脑表示外设寄存器地址">Level_1：无脑表示外设寄存器地址</h4>
<h5 id="宏定义：">宏定义：</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCC_APB2ENR *(uint*)0x40021018</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOB_CRL  *(uint*)0x40010C00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOB_ODR *(uint*)0x40010C0C</span></span><br></pre></td></tr></table></figure>
<h5 id="主函数：">主函数：</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********初始化*************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		1、开启GPIO端口时钟 </span></span><br><span class="line"><span class="comment">		2、端口清零</span></span><br><span class="line"><span class="comment">		3、配置输入/输出模式、输出速率</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//开启端口时钟</span></span><br><span class="line">RCC_APB2ENR |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清零控制PB0的端口位</span></span><br><span class="line">GPIOB_CRL &amp;= ~( <span class="number">0x0f</span> );</span><br><span class="line"><span class="comment">//配置PB0为通用推挽输出，速度为10M</span></span><br><span class="line">GPIOB_CRL |= <span class="number">1</span>;</span><br><span class="line"><span class="comment">/*********控制引脚电平输出*********/</span></span><br><span class="line"><span class="comment">//PB0输出低电平</span></span><br><span class="line">GPIOB_ODR &amp;= ~(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>上面这段代码值得说道的是，使用无符号整形指针对十六位地址进行强制类型转换，使一个十六进制数变成了地址标号。然后就顺理成章的在它前面加个“*”解引用，对那块十六进制数表示的地址赋值。手段很妙，学到了，orz。。。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(uint*)<span class="number">0x40010C0C</span>;		<span class="comment">//十六进制数地址化</span></span><br><span class="line">*(uint*)<span class="number">0x40010C0C</span>;		<span class="comment">//解引用</span></span><br></pre></td></tr></table></figure>
<p>但以上做法过于简单粗暴，每个寄存器都用一个8位十六进制表示，写起来麻烦不说，还容易出错且调试麻烦，代码的维护性比较困难。所以很自然的引申出level2版，基于基址+偏址的宏定义版本。</p>
<hr>
<h4 id="level-2-基于基址-偏址">Level_2: 基于基址+偏址</h4>
<p>我们可以看到，内存地址映射表的地址是分布是有规律的。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/image-20210422210004917.png" alt="image-20210422210004917"></p>
<p>从层次上，外设的起始地址是什么，属于哪条总线从表中可以看得一清二楚。</p>
<p>从顺序上，因为地址的连续性，所有外设的地址有连在一起有迹可循。</p>
<p>基于以上两点，我们就可以用一个地址作为基础地址（比如这里的0x4000 0000），然后根据各个总线起始地址与基础地址的差值，作为偏移量；外设的起始地址与外设所在的总线起始地址的差值作为偏移量。由此形成了多层级宏定义 的<strong>基址+偏址</strong>模式。</p>
<p>基址+偏址的方法的好处是，每次定义寄存器地址的时候都可以借用之前定义的宏，写的时候更加便于理解且调试比Level1方便不要太多。</p>
<h5 id="宏定义：">宏定义：</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外设宏定义 peripheral</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERIPH_BASE  			(uint)0x40000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> APB2PERIPH_BASE  		PERIPH_BASE+(0x10000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AHBPERIPH_BASE  		PERIPH_BASE+(0x20000)	<span class="comment">//时钟控制</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义时钟复位寄存器和GPIOB的基地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCC_BASE 		(AHBPERIPH_BASE+0X1000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOB_BASE		(APB2PERIPH_BASE + 0X0C00)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCC_APB2ENR		*(uint*)(RCC_BASE + 0X18)	<span class="comment">//apb2总线使能地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_CRL		*(uint*)(GPIOB_BASE + 0X00)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	GPIO_CRH		*(uint*)(GPIOB_BASE + 0X04)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_ODR		*(uint*)(GPIOB_BASE + 0X0C)</span></span><br></pre></td></tr></table></figure>
<h5 id="主函数：">主函数：</h5>
<p>同 level1。</p>
<p>本人用Level_2的方式耍了两个多小时，发现GPIO的宏定义都要加上同一个偏址且每次初始化GPIO端口干的是都差不多。这就导致产生了很多冗余代码，这能忍吗？必然不能！</p>
<p>因为每个GPIO口内部的地址都是规律连续的。所以很容易引申出Level_3——结构体与函数封装</p>
<hr>
<h4 id="level-3：初步封装">Level_3：初步封装</h4>
<h5 id="头文件：">头文件：</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">uint16_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************总线基址编号***********************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERIPHER_BASE           ((uint32_t)0x40000000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERIPHERAHB_BASE        (PERIPHER_BASE + 0x20000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERIPHERAPB2_BASE       (PERIPHER_BASE + 0x10000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************GPIO基址and时钟基址编号*********************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOA_BASE              (PERIPHERAPB2_BASE + 0x0800 )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOB_BASE              (PERIPHERAPB2_BASE + 0x0C00 )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCC_BASE                (PERIPHERAHB_BASE  + 0x1000 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************结构体设置*********************/</span></span><br><span class="line"><span class="comment">//GPIO</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> CRL;</span><br><span class="line">    <span class="keyword">uint32_t</span> CRH;</span><br><span class="line">    <span class="keyword">uint32_t</span> IDR;   </span><br><span class="line">    <span class="keyword">uint32_t</span> ODR;</span><br><span class="line">    <span class="keyword">uint32_t</span> BSRR;</span><br><span class="line">    <span class="keyword">uint32_t</span> BRR;</span><br><span class="line">    <span class="keyword">uint32_t</span> LCKR;</span><br><span class="line"></span><br><span class="line">&#125;GPIO_TypeDef;</span><br><span class="line"><span class="comment">//RCC</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> CRR_CR;</span><br><span class="line">    <span class="keyword">uint32_t</span> CRR_CFGR;</span><br><span class="line">    <span class="keyword">uint32_t</span> RCC_CIR;</span><br><span class="line">    <span class="keyword">uint32_t</span> RCC_APB2RSTR;</span><br><span class="line">    <span class="keyword">uint32_t</span> RCC_APB1RSTR;</span><br><span class="line">    <span class="keyword">uint32_t</span> RCC_AHBENR;</span><br><span class="line">    <span class="keyword">uint32_t</span> RCC_APB2ENR;</span><br><span class="line">    <span class="keyword">uint32_t</span> RCC_APB1ENR;</span><br><span class="line">    <span class="keyword">uint32_t</span> RCC_BDCR;</span><br><span class="line">    <span class="keyword">uint32_t</span> RCC_CSR;</span><br><span class="line">&#125;RCC_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************编号转化为地址****************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOA                   ((GPIO_TypeDef*) GPIOA_BASE) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOB                   ((GPIO_TypeDef*) GPIOB_BASE)     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCC                     ((RCC_TypeDef* ) RCC_BASE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************GPIO引脚*************************/</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        以下宏定义一般用于IDR or ODR的配置，所以一般16位即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_0              ((uint16_t)0x0001)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_1              ((uint16_t)0x0002)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_2              ((uint16_t)0x0004)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_3              ((uint16_t)0x0008)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_4              ((uint16_t)0x0010)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_5              ((uint16_t)0x0020)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_6              ((uint16_t)0x0040)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_7              ((uint16_t)0x0080)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_8              ((uint16_t)0x0100)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_9              ((uint16_t)0x0200)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_10             ((uint16_t)0x0400)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_11             ((uint16_t)0x0800)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_12             ((uint16_t)0x1000)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_13             ((uint16_t)0x2000)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_14             ((uint16_t)0x4000)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_15             ((uint16_t)0x8000)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_ALL            ((uint16_t)0xffff)</span></span><br><span class="line"> <span class="comment">/*************************RCC引脚*************************/</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> RCC_GPIOA             ((uint32_t)0x00000004)</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> RCC_GPIOB             ((uint32_t)0x00000008)</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> enum&#123; ENABLE = 0, UNENABLE = 1&#125;State;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*******************初始化变量枚举定义***********************/</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;</span><br><span class="line">        GPIO_SPEED_10MHz = <span class="number">1</span>,</span><br><span class="line">        GPIO_SPEED_20MHz ,</span><br><span class="line">        GPIO_SPEED_50MHz ,</span><br><span class="line">    &#125;GPIOSPEED_TypeDef;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;</span><br><span class="line">        GPIO_MODE_AIN = <span class="number">0x0</span>,</span><br><span class="line">        GPIO_MODE_AIN = <span class="number">0x4</span>,</span><br><span class="line">        GPIO_MODE_AIN = <span class="number">0X28</span>,</span><br><span class="line">        GPIO_MODE_AIN = <span class="number">0x48</span>,</span><br><span class="line"></span><br><span class="line">        GPIO_MODE_AIN = <span class="number">0x14</span>,</span><br><span class="line">        GPIO_MODE_AIN = <span class="number">0x10</span>,</span><br><span class="line">        GPIO_MODE_AIN = <span class="number">0x1C</span>,</span><br><span class="line">        GPIO_MODE_AIN = <span class="number">0x18</span></span><br><span class="line">    &#125;GPIOMODE_TypeDef;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/******************GPIO初始化结构体******************/</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">uint16_t</span> Pin;</span><br><span class="line">        GPIOSPEED_TypeDef Speed;</span><br><span class="line">        GPIOMODE_TypeDef Mode;</span><br><span class="line">    &#125;GPIO_InitTypeDef;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/***********************相关库函数**************************/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RCC_InitConfig</span><span class="params">(RCC_TypeDef*RCC_Def,State NewState)</span></span>;		</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GPIOx_Setbit</span><span class="params">(GPIO_TypeDef*GPIOx,<span class="keyword">uint16_t</span> Pin)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GPIOx_Retbit</span><span class="params">(GPIO_TypeDef*GPIOx,<span class="keyword">uint16_t</span> Pin)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GPIOx_Cofig</span><span class="params">(GPIO_TypeDef*GPIOx,GPIO_InitTypeDef* GPIO_Init)</span></span>;</span><br></pre></td></tr></table></figure>
<p>做完以上的工作，就可以对初步的对GPIO为所欲为了。</p>
<p>至于上面4个库函数的实现分析，请移步以下链接：【链接】（此坑待填。。。）</p>
<h5 id="主函数：">主函数：</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_INIT;</span><br><span class="line">    <span class="comment">/***********时钟配置************/</span></span><br><span class="line">	RCC_InitConfig(LED_CLK,ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***********GPIO初始化**********/</span></span><br><span class="line">    GPIO_INIT.GPIO_Pin 	 = GPIO_PIN_0;</span><br><span class="line">	GPIO_INIT.GPIO_Mode	 = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_INIT.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB,&amp;GPIO_INIT);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		GPIOx_Setbit(GPIOB,GPIO_PIN_0);</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此基于寄存器编程的基本操作原理算是结束了。</p>
<h4 id="总结：">总结：</h4>
<p>纯寄存器编程而言应该是Level_2的阶段，Leve_3因为封装使用了函数调用，比只用寄存器而言消耗的cpu资源必然会更多。不过只要不是对性能苛刻到相当高的程度的话，这点开销就没必要计较了。</p>
<p>总的来说，寄存器编程开发遵从以下步骤：</p>
<ul>
<li>看着数据手册，先把相关的寄存器映射、引脚顺序定义</li>
<li>根据需求找到对应的寄存器</li>
<li>利用定好的引脚去改变寄存器的值</li>
</ul>
<h4 id="寄存器编程的意义">寄存器编程的意义</h4>
<ul>
<li>开销低，抠性能的时候就是它发挥威力的时候。</li>
<li>当芯片商家没有提供相关底层库时可以自食其力（以后不可能只用st公司的芯片不是）</li>
<li>用库时做到心中有数，出bug时可以有的放矢（不要过分相信官方库）。</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>MCU</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>链表习题整理</title>
    <url>/2021/01/03/DSA/BaseDataStructures/%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>发现自己对用结构体实现的链表操作好像不太熟，就补补漏吧。</p>
<p>本文是对链表一些常见题目的整理，对于其中自己相对不太熟悉的技巧，加以提炼总结。</p>
</blockquote>
<a id="more"></a>
<h2 id="原题链接">原题链接</h2>
<p><a href="https://www.acwing.com/problem/content/18/"> 从尾到头打印链表</a></p>
<h2 id="选题分析">选题分析</h2>
<hr>
<p>此坑待填~~~</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>基础数据结构</category>
      </categories>
      <tags>
        <tag>线性结构</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言(一)基础知识与寄存器</title>
    <url>/2020/12/19/Embedded/Assembly/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E4%B8%80)%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>这是一个记录本人学习汇编的笔记及思考的系列文章。</p>
<p>本文为王爽的《汇编语言》第1-3章笔记。</p>
<p>按照我的个人习惯，我会尽量把每个知识点的前后逻辑关系、相关的学习感悟都捋丝滑，尽力做到水到渠成。但若想系统学习汇编语言，个人觉得还是有必要自己去刷一遍王爽的《编译语言》。</p>
</blockquote>
<a id="more"></a>
<h2 id="本文导图">本文导图</h2>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/20210309051909.png" alt="汇编语言"></p>
<h2 id="时刻铭记">时刻铭记</h2>
<p>学习汇编的主要目的，是通过用汇编语言进行编程而深入地理解计算机底层的基本工作机理。</p>
<h2 id="1-基础知识">1、基础知识</h2>
<p>基础知识部分主要介绍了什么是汇编？CPU对内存的处理方式等。</p>
<h3 id="1-1-汇编语言的组成">1.1、汇编语言的组成</h3>
<ul>
<li>汇编指令：机器码（01串）的符号化表现。</li>
<li>伪指令：没有对应的机器码，它是给编译器看的。</li>
<li>其他符号：如+、-、*、/等。</li>
</ul>
<p>很显然，这部分最重要的是汇编指令，但其它两类也是必不可少的，至于原因，后面会说。</p>
<h3 id="1-2-指令和数据">1.2、指令和数据</h3>
<p>指令和数据是人为定义的东西，它是应用上的概念。对于cpu而言，它只认得0和1，所以指令和数据对CPU来说，从本质上来讲是没有任何区别的。</p>
<img align="right" src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/20210309051928.png" alt="1.2存储单元" style="zoom:60%;" />
<p>而一位的0和1只能表示两种不同的状态，想要表示出指令和数据，我们就需要使用多位的二进制数去表示指令和数据。为了操作的统一和方便，CS的前辈们就以 8bit，即<strong>1Byte，作为最基本的存储单元。</strong></p>
<p>这样，我们就可以把存储器划分成若干个存储单元，并给每个存储单元编上编号（<strong>编号从0开始</strong>），方便我们后续操作存储单元内的数据。</p>
<p>（对于这个存储单元的理解，可以类比“化学变化中的最小粒子是原子”。而bit之于Byte的关系，电子、质子之于原子的关系是一样的。）</p>
<h3 id="1-3-cpu对存储器的读写">1.3、CPU对存储器的读写</h3>
<p>CPU要从内存中读取数据，即它必须和外部器件（如：存储器）进行以下3种最基本的信息交互：</p>
<ul>
<li>地址信息：想要操作的数据在哪里。</li>
<li>控制信息：选择哪个器件、要对这个器件做什么事，如：读or写。</li>
<li>数据信息：要读or写的信息。</li>
</ul>
<img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/20210309052319.png" alt="1.3CPU读取数据" style="zoom:65%;" />
<p>有意思的是，以上罗列的3种交互方式的顺序是具备逻辑性的：</p>
<ol>
<li>CPU得先知道你想对哪个地址操作，它才好决定选哪个外部器件。</li>
<li>知道应该选择哪个外部器件之后，才好发出相对应的控制信息。</li>
<li>最后完成数据信息的处理过程。</li>
</ol>
<h3 id="1-4-总线">1.4、总线</h3>
<p>从1.3的图，我们也可以知道CPU和外部器件进行信息交互是通过在器件与cpu间连接线实现的。而从保证器件传输信息的稳定性角度看，一根线最多只能表示两种状态(高电平or低电平) or 一个数字，所以每种作用的线都不可能只有一根，根据作用的不同，我们分别给这3种线一个名字：</p>
<ul>
<li>地址总线：线数的多寡决定CPU可以对多少不同的地址进行寻址。</li>
<li>控制总线：线数的多寡决定CPU有多少种控制方式</li>
<li>数据总线：线数的多寡决定CPU一次能传输多少位数字</li>
</ul>
<p>设N为总线的线数，那么</p>
<ul>
<li>地址总线，可以寻址的范围为 2<sup>n</sup> 个存储单元。</li>
<li>控制总线，可以有 2<sup>n</sup> 种控制模式。</li>
<li>数据总线，一次性能传输 N 位的数据。</li>
</ul>
<h3 id="1-5-存储器芯片">1.5、存储器芯片</h3>
<p>计算机中装有多个存储芯片。这些芯片从物理角度看是独立的、不同的器件。</p>
<p>而我们的重点是从读写属性以及功能上对存储器进行认识。</p>
<p>从读写属性上可分为：</p>
<ul>
<li>随机存储器(RAM):可以随机对存储器内的任意地址进行读or写，但必须带电存储。</li>
<li>只读存储器(ROM): 只能读不能写。</li>
</ul>
<p>从功能上可分为：</p>
<ul>
<li>主RAM：存放CPU使用的绝大多数程序and数据。一般有主板和扩展插槽上的RAM组成</li>
<li>装有BIOS的ROM：如显卡、网卡。存放基本IO信息和对应软件系统。</li>
<li>接口卡上的RAM：如显存这类需要在接口卡上进行大批量的输入、输出数据的暂时存储。</li>
</ul>
<p>（补充：接口卡，即外部设备插入主板扩展插槽的那排东东。）</p>
<h3 id="1-6-内存地址空间">1.6、内存地址空间</h3>
<p>为了统筹处理各个外部器件，我们可以把所有外部设备的内存地址都映射到一个一维的逻辑存储器上。如下图，这样，CPU就可以轻松的对外部设备的内存地址进行管理了。</p>
<img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/20210309052356.png" alt="1.4逻辑存储器" style="zoom:60%;" />
<p>这里唯一值得注意的是，不同CPU对外设的内存分配情况是不同的。上图仅为8086的内存映射情况。</p>
<h2 id="2-寄存器">2、寄存器</h2>
<h3 id="2-1">2.1、</h3>
<hr>
<p>未完待续~~~</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客-数学考试</title>
    <url>/2020/11/05/Solution/NiuKe/%E7%89%9B%E5%AE%A2%20%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<p>原题链接：<a href="https://ac.nowcoder.com/acm/problem/15553">https://ac.nowcoder.com/acm/problem/15553</a></p>
<h2 id="题目">题目</h2>
<p>今天qwb要参加一个数学考试，这套试卷一共有n道题，每道题qwb能获得的分数为ai，qwb并不打算把这些题全做完，<br>
他想选总共2k道题来做，并且期望他能获得的分数尽可能的大，他准备选2个不连续的长度为k的区间,<br>
即[L,L+1,L+2,…,L+k-1]，[R,R+1,R+2,…,R+k-1]（R &gt;= L+k）。</p>
<a id="more"></a>
<h2 id="输入">输入</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行一个整数T（T&lt;&#x3D;10）,代表有T组数据</span><br><span class="line">接下来一行两个整数n,k,(1&lt;&#x3D;n&lt;&#x3D;200,000),(1&lt;&#x3D;k,2k &lt;&#x3D; n)</span><br><span class="line">接下来一行n个整数a1,a2,...,an，（-100,000&lt;&#x3D;ai&lt;&#x3D;100,000）</span><br></pre></td></tr></table></figure>
<h2 id="输出">输出</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出一个整数，qwb能获得的最大分数</span><br></pre></td></tr></table></figure>
<h2 id="分析">分析</h2>
<p>首先预判下该题的时间复杂度。n&lt;=200,000,极限数据下n<sup>2</sup>会TLE，所以可推断出时间复杂度至多为<strong>nlogn</strong>量级。再看题划重点——选2个不连续的长度为k的区间，即：“求两个固定长度的最大区间和”，那么很自然想到用前缀和。</p>
<p>首先，我们可以从左往右找到一个长度为k的最大区间和，记作：<strong>Ma</strong>。</p>
<p>所以，</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mrow><mo fence="true">{</mo><mi>M</mi><mi>a</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mi>k</mi><mo stretchy="false">]</mo><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">Ma=max\left\{Ma,a[i]-a[i-k]\right\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span></span></p>
<p>对于求<strong>Ma</strong>过程中扫描过的每个<strong>a[i]</strong>,我们都可以找到一个与之对应的区间和<strong>a[i+k]-a[i]</strong>。</p>
<p>所以要求的两个不连续最大区间和，就等于<strong>Ma</strong>+**a[i+k]-a[i]**的最大值,即：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mrow><mo fence="true">{</mo><mi>a</mi><mi>n</mi><mi>s</mi><mo separator="true">,</mo><mi>M</mi><mi>a</mi><mo>+</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mi>k</mi><mo stretchy="false">]</mo><mo>−</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">ans=max\left\{ans,Ma+a[i+k]-a[i]\right\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span></span></p>
<p>这个算法的时间复杂度是O(n)，在接受范围之内。</p>
<p>最后需要注意的是，极限数据答案为2<sup>5</sup>×10<sup>5</sup>&gt;2<sup>31</sup>-1，即：会爆int。所以数组<strong>a</strong>，第一个区间最大和<strong>Ma</strong>和最后答案<strong>ans</strong>,都要开成<strong>long long</strong>。</p>
<h2 id="代码">代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="keyword">int</span> n,k;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;a[i],a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">		</span><br><span class="line">		ll Ma=<span class="number">-1e10</span>,ans=<span class="number">-1e10</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=k;i+k&lt;=n;i++)&#123;</span><br><span class="line">			Ma=max(Ma,a[i]-a[i-k]);</span><br><span class="line">			ans=max(ans,Ma+a[i+k]-a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客-再编号</title>
    <url>/2020/11/04/Solution/NiuKe/%E7%89%9B%E5%AE%A2%20%E5%86%8D%E7%BC%96%E5%8F%B7/</url>
    <content><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/17375">https://ac.nowcoder.com/acm/problem/17375</a><br>
来源：牛客网</p>
<h2 id="题目描述">题目描述</h2>
<p>n 个人，每个人有一个编号 a<sub>i</sub> 。</p>
<p>定义对 a  的再编号为 a’ ，满足：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>a</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo>=</mo><mo stretchy="false">(</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>a</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>−</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a&#x27;_i=(\sum_{j=1}^{n}a_j)-a_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0651740000000007em;vertical-align:-1.4137769999999998em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000007em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>现在有 m 次询问，每次给定 x,t ，表示询问经过 t 次再编号后第 x 个人的编号。</p>
<p>由于答案可能很大，所以对 10<sup>9</sup>+7 取模。</p>
<a id="more"></a>
<h2 id="输入描述">输入描述:</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行 2 个数 n,m ，表示人数和询问次数；</span><br><span class="line"></span><br><span class="line">接下来一行 n 个数，表示 ai；</span><br><span class="line"></span><br><span class="line">接下来 m 行，每行 2 个数 x,t ，描述一次询问。</span><br></pre></td></tr></table></figure>
<h2 id="输出描述">输出描述:</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m 行，第 i 行 1 个数表示第 i 次询问的答案对 10^9+7 取模的结果。</span><br></pre></td></tr></table></figure>
<h2 id="样例输入">样例输入</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2 3 4</span><br><span class="line">1 0</span><br><span class="line">2 2</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure>
<h2 id="样例输出">样例输出</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">22</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<h2 id="说明">说明</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始编号：1  2  3  4</span><br><span class="line"></span><br><span class="line">1 次再编号后：9  8  7  6</span><br><span class="line"></span><br><span class="line">2 次再编号后：21  22  23  24</span><br></pre></td></tr></table></figure>
<h2 id="备注">备注</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n ≤ 100000 , m ≤ 10000 , t ≤ 100000 , 1 ≤ ai ≤ 109</span><br></pre></td></tr></table></figure>
<h2 id="分析">分析</h2>
<p>首先简单看一眼数据范围，复杂度应该要控制在**O(NlogN)**以内。</p>
<p>题目要求询问<strong>m</strong>次，每次询问输出迭代第<strong>t</strong>次后位置<strong>x</strong>的值。最容易想到的是预处理存储迭代10<sup>5</sup>的所有结果，然后对于每次询问直接输出答案。这种方法时间复杂度是<strong>O(n<sup>2</sup>)</strong>，且需要开的数组很大，大概率会爆空间~~(我比较懒，没有仔细算)~~显然行不通。</p>
<p>那么，我们来研究下题目给出的公式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>a</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo>=</mo><mo stretchy="false">(</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>a</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>−</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a&#x27;_i=(\sum_{j=1}^{n}a_j)-a_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0651740000000007em;vertical-align:-1.4137769999999998em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000007em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>即：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>a</mi><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">)</mo><mo>−</mo><msub><mi>a</mi><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mspace linebreak="newline"></mspace><msub><mi>a</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><mo>=</mo><msub><mi>S</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>a</mi><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">a_{it}=(\sum_{i=1}^{n}a_{i(t-1)})-a_{i(t-1)}\\
a_{it}=S_{t-1}-a_{i(t-1)}\\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7857599999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7857599999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span></span></span></span></p>
<p>其中a<sub>it</sub>表示ai经过t次迭代后的值，S<sub>t</sub>表示t次迭代后数组的总和</p>
<p>然后，我们很容易写出下面的推导式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>t</mi></msub><mo>=</mo><mi>n</mi><msub><mi>S</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo>−</mo><msub><mi>a</mi><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mspace linebreak="newline"></mspace><msub><mi>S</mi><mi>t</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><msub><mi>S</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_{t}=nS_{t-1}\sum_{i=1}^n-a_{i(t-1)}\\
S_{t}=(n-1)S_{t-1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>得到了一个看起来很nice的推导式。</p>
<p>然而，这个推导式只能优化我们算出St的效率，</p>
<p>搜了下大佬们写的题解，说是观察原数列得出无论经过几轮迭代，数列中相邻两个数的差的绝对值不变。我不信邪的证明了下~~（证明过程不想看的可以选择跳过）~~。</p>
<h3 id="证：">证：</h3>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∵</mo><mspace width="1em"/><mspace width="1em"/><msub><mi>a</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><mo>=</mo><msub><mi>S</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>a</mi><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mspace linebreak="newline" height="0.8em"></mspace><mo>∴</mo><mtext>设</mtext><mspace width="1em"/><msub><mi>a</mi><mrow><mi>k</mi><mi>t</mi></mrow></msub><mo>=</mo><msub><mi>S</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>a</mi><mrow><mi>k</mi><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mtext> ①</mtext><mo separator="true">,</mo><mspace linebreak="newline" height="0.8em"></mspace><mtext>  </mtext><msub><mi>a</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>t</mi></mrow></msub><mo>=</mo><msub><mi>S</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>a</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mtext> ②</mtext><mspace linebreak="newline" height="0.8em"></mspace><mo>∴</mo><mtext>②</mtext><mo>−</mo><mtext>①：</mtext><mspace width="1em"/><msub><mi>a</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>t</mi></mrow></msub><mo>−</mo><msub><mi>a</mi><mrow><mi>k</mi><mi>t</mi></mrow></msub><mo>=</mo><mspace linebreak="newline" height="0.8em"></mspace><mo>−</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo>−</mo><msub><mi>a</mi><mrow><mi>k</mi><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">∵\quad\quad  a_{it}=S_{t-1}-a_{i(t-1)} \\[8pt]
∴设\quad a_{kt}=S_{t-1}-a_{k(t-1)}\ ①,\\[8pt]
\ \ a_{(k+1)t}=S_{t-1}-a_{(k+1)(t-1)}\ ②\\[8pt]
∴②-①：\quad a_{(k+1)t}-a_{kt}=\\[8pt]
-(a_{(k+1)(t-1)}-a_{k(t-1)})
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∵</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7857599999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline" style="margin-top:0.8em;"></span><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">设</span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7857599999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord">①</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span></span><span class="mspace newline" style="margin-top:0.8em;"></span><span class="base"><span class="strut" style="height:0.7857599999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7857599999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord">②</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline" style="margin-top:0.8em;"></span><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">②</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord">①</span><span class="mord cjk_fallback">：</span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline" style="margin-top:0.8em;"></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>同理可得：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mi>t</mi></mrow></msub><mo>−</mo><msub><mi>a</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>t</mi></mrow></msub><mo>=</mo><mspace linebreak="newline" height="0.8em"></mspace><mo>−</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo>−</mo><msub><mi>a</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_{(k+2)t}-a_{(k+1)t}=\\[8pt]
-(a_{(k+2)(t-1)}-a_{(k+1)(t-1)})
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9385299999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mclose mtight">)</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7857599999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline" style="margin-top:0.8em;"></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mclose mtight">)</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>所以</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>t</mi></mrow></msub><mo>−</mo><msub><mi>a</mi><mrow><mi>k</mi><mi>t</mi></mrow></msub><mo>=</mo><msub><mi>a</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mi>t</mi></mrow></msub><mo>−</mo><msub><mi>a</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{(k+1)t}-a_{kt}=a_{(k+2)t}-a_{(k+1)t}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9385299999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9385299999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mclose mtight">)</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7857599999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>由此可以证明，经过n次迭代后，数列中相邻两个数的差的绝对值不变，且奇数次迭代的差值为初始数列的相反数，偶数迭代与初始数相同。</p>
<p>进而可以得出推论：<strong>经过n次迭代后，数列中任意两个位置的数的差的绝对值不变。</strong></p>
<p>这样一来，那么我们就可以预处理所有<strong>a<sub>1t</sub><strong>和</strong>D<sub>i</sub></strong>,其中**D<sub>i</sub>**表示数列中第i个数与第一个数的差值。</p>
<p>对于每次询问,答案即为：</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: equation at position 7: \begin{̲e̲q̲u̲a̲t̲i̲o̲n̲}̲
ans = \left\{
…'>\begin{equation}
ans = \left\{
\begin{aligned}
an[t]-D[x] &amp; &amp; t为奇数\\
an[t]+D[x] &amp; &amp; t为偶数
\end{aligned}
\right.
\end{equation}
</p>
<p>即一次询问的时间复杂度为<strong>O(1)</strong>,总时间复杂度为**O(m)**可以接受。</p>
<p>最后还有个小细节值得注意：因为可能存在极限数据，使得an[t]-D[x]&lt;0、an[t]=S<sub>t</sub>-an[t-1]&lt;0,所以对于这两种情况，取模前需要先加上模值。</p>
<h2 id="代码">代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line">ll a[N],an[N],D[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;a[<span class="number">1</span>];</span><br><span class="line">	ll sum;</span><br><span class="line">	sum=a[<span class="number">1</span>],D[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">		D[i]=(a[i]-a[<span class="number">1</span>]+mod)%mod;</span><br><span class="line">		sum=(sum+a[i])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	an[<span class="number">0</span>]=a[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">100005</span>;i++)&#123;</span><br><span class="line">		an[i]=(sum-an[i<span class="number">-1</span>]+mod)%mod;</span><br><span class="line">		sum=((n<span class="number">-1</span>)*sum)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="keyword">int</span> x,t;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;x,&amp;t);</span><br><span class="line">		<span class="keyword">if</span>(t%<span class="number">2</span>)<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(an[t]-D[x]+mod)%mod);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(an[t]+D[x])%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结">小结</h2>
<p>1、当思路卡住时，回归样例，仔细观察规律。</p>
<p>2、注意减法取模，可能存在小于0的情况，保险做法是先加模数再取模。</p>
<p>参考资料：<a href="https://www.cnblogs.com/bljfy/p/9532789.html">https://www.cnblogs.com/bljfy/p/9532789.html</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>差分数组原理</title>
    <url>/2020/11/03/DSA/BaseAlgotirhm/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>考虑这么一个问题：让一个区间内的所有数同时加、减、乘、除上同一个数，这是一种很常见的操作。</p>
<p>而对于这操作，最简单的做法就是用循环逐一对区间内所有数进行操作。这种方法的时间复杂度是<strong>O(n)</strong>。</p>
<p>但是若数据量级达到百万千万级别以上，频繁的进行区间修改的话，**O(n)**复杂度还是太慢了。</p>
<p>而对于一组不会发生增删节点的离线数据来说，差分数组是区间修改的最优选择。</p>
</blockquote>
<a id="more"></a>
<h2 id="原理">原理</h2>
<p>差分，其实可以看成前缀和的一种逆运算。即：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">b[i]=a[i]-a[i-1]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></p>
<p>其中<strong>a[i]<strong>为原数组</strong>(你也可以把它看成前缀和数组)</strong>，**b[i]**为差分数组。</p>
<p>我们知道前缀和的公式是</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>b</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a[i]=b[i]+a[i-1]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></p>
<p>所以若对b[i]进行修改，那么包括位置i以后的所有前缀和都会发生相同变化。</p>
<table>
<thead>
<tr>
<th style="text-align:center">a[n]</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">（1）</td>
<td style="text-align:center">b[1]</td>
<td style="text-align:center">b[1]+b[2]</td>
<td style="text-align:center">b[1]+b[2]+b[3]</td>
<td style="text-align:center">b[1]+b[2]+b[3]+b[4]</td>
<td style="text-align:center">b[1]+b[2]+b[3]+b[4]+b[5]</td>
</tr>
<tr>
<td style="text-align:center">（2）</td>
<td style="text-align:center"></td>
<td style="text-align:center"><strong>b[1]+(b[2]+c)</strong></td>
<td style="text-align:center">b[1]+(b[2]+c)+b[3]</td>
<td style="text-align:center">b[1]+(b[2]+c)+b[3]+b[4]</td>
<td style="text-align:center">b[1]+(b[2]+c)+b[3]+b[4]+b[5]</td>
</tr>
<tr>
<td style="text-align:center">（3）</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"><strong>b[1]+(b[2]+c)+b[3]+(b[4]-c)</strong></td>
<td style="text-align:center">b[1]+(b[2]+c)+b[3]+(b[4]-c)+b[5]</td>
</tr>
<tr>
<td style="text-align:center">（4）</td>
<td style="text-align:center">b[1]</td>
<td style="text-align:center"><strong>b[1]+(b[2]+c)</strong></td>
<td style="text-align:center"><strong>b[1]+(b[2]+c)+b[3]</strong></td>
<td style="text-align:center">b[1]+b[2]+b[3]+b[4]</td>
<td style="text-align:center">b[1]+b[2]+b[3]+b[4]+b[5]</td>
</tr>
</tbody>
</table>
<p>如上表（2）所示，<strong>b[2]<strong>加上了一个常数</strong>c</strong>，前缀和数组<strong>a[2,3,4,5]<strong>都加上了</strong>c</strong>。</p>
<p>而(3)中对b[4]减去了c，所以a[4]往后的前缀和都减去了c。</p>
<p>得到了（4），只修改了<strong>a[2]</strong>、<strong>a[3]<strong>的效果。即让</strong>a[2,3]+c</strong>。</p>
<p>因此若需要多次指定不同区间进行操作，使用差分可以实现**时间复杂度O(1)**的单次修改区间。</p>
<p>但，如果每次修改完区间都需要实时反馈，那暴力显然是比差分数组更优的策略。想在暴力上再进行优化的话就只能用线段树or树状数组了。</p>
<h2 id="代码">代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	模板题：https://www.acwing.com/problem/content/799/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	b[l]+=c;</span><br><span class="line">	b[r+<span class="number">1</span>]-=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">//读取数组、建立差分数组b[n] </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">		insert(i,i,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//每次修改区间值，即m次修改差分数组b </span></span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="keyword">int</span> l,r,c;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);</span><br><span class="line">		insert(l,r,c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//利用差分数组求前缀和，即求原数组 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		a[i]=a[i<span class="number">-1</span>]+b[i];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理可写出：二维差分数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	模板题：https://www.acwing.com/problem/content/800/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N],temp[N][N]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	temp[x1][y1]+=c;</span><br><span class="line">	temp[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">	temp[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">	temp[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,q;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">	<span class="comment">//建立差分数组 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">			insert(i,j,i,j,a[i][j]);</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">				因插入时是一点，可以看做：</span></span><br><span class="line"><span class="comment">					x1、x2融合 </span></span><br><span class="line"><span class="comment">					y1、y2融合 </span></span><br><span class="line"><span class="comment">			*/</span> </span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//对差分矩阵修改 </span></span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="keyword">int</span> x1,y1,x2,y2,c;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;</span><br><span class="line">		insert(x1,y1,x2,y2,c); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//重建前缀和矩阵，即求原数组 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123; </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			a[i][j]=temp[i][j]+a[i<span class="number">-1</span>][j]+a[i][j<span class="number">-1</span>]-a[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;a[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结">小结</h2>
<p>利用差分数组修改区间需要<strong>创建差分数组</strong>、<strong>重建前缀和数组</strong>(即原数组)两个过程。</p>
<p>因此少次的区间修改时，效率上并不比直接使用循环要高，所以对离线数列区间修改时，应注意相关的使用场景。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>差分数组</tag>
      </tags>
  </entry>
  <entry>
    <title>第十一届蓝桥杯B组—E矩阵</title>
    <url>/2020/10/14/Solution/LanQiao/%E7%AC%AC%E5%8D%81%E4%B8%80%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AFB%E7%BB%84%E2%80%94E%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h3 id="问题描述">问题描述</h3>
<blockquote>
<p>把 1 ∼ 2020 放在 2 × 1010 的矩阵里。</p>
<p>要求同一行中右边的比左边大，同一列中下边的比上边的大。一共有多少种方案？</p>
<p>答案很大，你只需要给出方案数除以 2020 的余数即可。</p>
</blockquote>
<p><strong>答案提交</strong><br>
这是一道结果填空题，你只需要算出结果后提交即可。<br>
本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p>
<a id="more"></a>
<h3 id="分析">分析</h3>
<p>由题意我们大概可以简要得到下图的信息。</p>
<img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/20210309051634.PNG" alt="示例图（1）" style="zoom:50%;" />
$$
\begin{cases}
  A<C<D \\
  A<B<D
<p>\end{cases}</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 345: …:33%;&quot; /&gt;

上述的 $̲ f\[i][j] $表示第一…'>从上图示意中，我们可以发现A一定是最小的数。而与A相邻的B和C一定是仅小于A的两个数。例如：**若A=1，那么D绝对不可能等于2。**

因此，对于每个数的放法，一定是从最左边开始的。

对于一个新放的数：

- 要么紧挨着放在上边一行
- 要么紧挨着放在下边一行

且对于第二种情况必然是建立在上边一行已经放置的情况之下。

这种后一个的放法，仅受前一个放法影响的问题，显然具备无后效性，可以用DP的思想思考它。

&lt;img src=&quot;https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/20210309051649.PNG&quot; alt=&quot;DP分析过程&quot; style=&quot;zoom:33%;&quot; /&gt;

上述的 $ f\[i][j] $表示第一行有 i 个数，第二行有 j 个数放法。

当我们要放一个数的时,合理放法（即: **i - 1 ≥  j**）:

- 若放第一行，那放法数就有f\[ i-1 ][ j ] 种
- 若放第二行，那放法数就有f\[ i ][ j-1 ] 种

经我们上面的推导，**第一行已放置的i个数的个数必然大于等于第二行已放置的j个数的个数**。

所以，当出现如下图这种$ i = j $的情况时：

![流程解释](https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/20210309051726.png)

新的数必然只能放第一行，此时的放法总数与 $ f\[i][j-1]  $ 相等。

所以综上所述
</p>
<p>f[i][j]=<br>
\begin{cases}<br>
f[i-1][j]+f[i][j-1] \quad ,i-1≥j\<br>
f[i][j-1]\quad \quad\quad\quad\quad\quad, i-1&lt;j<br>
\end{cases}</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 3: 

#̲### 代码

&lt;!--cod…'>

#### 代码

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1020</span>][<span class="number">1020</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;               <span class="comment">// 两行一个数字都不放，也是一种方案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1010</span>; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= j)    </span><br><span class="line">            	f[i][j] += f[i - <span class="number">1</span>][j] % <span class="number">2020</span>;</span><br><span class="line">            <span class="keyword">if</span>(j)</span><br><span class="line">            	f[i][j] += f[i][j - <span class="number">1</span>] % <span class="number">2020</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   	<span class="built_in">cout</span>&lt;&lt;f[<span class="number">1010</span>][<span class="number">1010</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

这题其实是经典例题[Acwing 271. 杨老师的照相排列](https://www.acwing.com/problem/content/description/273/)的简化版。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯 整数拼接</title>
    <url>/2020/10/14/Solution/LanQiao/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%95%B4%E6%95%B0%E6%8B%BC%E6%8E%A5/</url>
    <content><![CDATA[<p><a href="https://www.acwing.com/problem/content/2070/">题目链接</a></p>
<h3 id="问题描述">问题描述</h3>
<p>给定一个长度为 n 的数组 A<sub>1</sub> , A<sub>2</sub> ,⋅⋅⋅, A<sub>n</sub> 。</p>
<p>你可以从中选出两个数 A<sub>i</sub> 和A<sub>j</sub>   (i 不等于 j)，然后将 A<sub>i</sub>  和 A<sub>j</sub> 一前一后拼成一个新的整数。</p>
<p>例如 12 和 345 可以拼成 12345 或 34512。</p>
<p>注意交换 A<sub>i</sub>  和 A<sub>j</sub>   的顺序总是被视为 2种拼法，即便是  A<sub>i</sub>  = A<sub>j</sub>   时。</p>
<p>请你计算有多少种拼法满足拼出的整数是 K 的倍数。</p>
<a id="more"></a>
<h4 id="输入格式">输入格式</h4>
<p>第一行包含 22 个整数 n 和 K。</p>
<p>第二行包含 n 个整数  A<sub>1</sub> , A<sub>2</sub> ,⋅⋅⋅, A<sub>n</sub> 。</p>
<h4 id="输出格式">输出格式</h4>
<p>一个整数代表答案。</p>
<h4 id="数据范围">数据范围</h4>
<p>1≤ n ≤10<sup>5</sup><br>
1≤ K ≤10<sup>5</sup><br>
1≤  A<sub>i</sub>  ≤10<sup>9</sup></p>
<h4 id="输入样例：">输入样例：</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure>
<h4 id="输出样例：">输出样例：</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
<h3 id="分析">分析</h3>
<p>求拼接数为k的倍数的个数。感觉跟<a href="#">Post not found: 蓝桥杯-k倍区间 蓝桥杯-k倍区间</a>有点像。于是思路往那边靠拢。<s>(瞄了一眼数据范围暴力明显不行，且有思路，就先不写暴力了)</s></p>
<p>按照题目大意，两个拼接数可以表示成如下形式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub><mi>a</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow></msup><mo>+</mo><mi>a</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">S=a[i]×10^{log_{10}a[j]}+a[j]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0213299999999998em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathdefault mtight">a</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">]</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span></p>
<p>那么求S是否是k的倍数，就可以转换为求</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub><mi>a</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow></msup><mspace width="1em"/><mi mathvariant="normal">%</mi><mspace width="1em"/><mi>k</mi><mo stretchy="false">)</mo><mspace width="1em"/><mo>=</mo><mspace width="1em"/><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mi mathvariant="normal">%</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a[i]×10^{log_{10}a[j]} \quad \% \quad k) \quad =\quad (a[j]\%k)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathdefault mtight">a</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">]</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord">%</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mord">%</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></span></p>
<p>的配对数。这个求解过程，跟<a href="#">Post not found: 蓝桥杯-k倍区间 蓝桥杯-k倍区间</a>是一样的，这里不做过多赘述。</p>
<p>不同的是，这里对于每个a[i]，都需要乘于一个系数  <strong>10<sup>log<sub>10</sub>a[j]</sup></strong> 。我们虽然不能预知每一个数的位数，但由1≤  A<sub>i</sub>  ≤10<sup>9</sup>可以得到a[i]的位数的取值范围在【1，10】之间。即:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>o</mi><mi>w</mi><mi>e</mi><mi>r</mi><mo>∈</mo><mn>1</mn><msup><mn>0</mn><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">]</mo></mrow></msup></mrow><annotation encoding="application/x-tex">Power \in 10^{[0,10]}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.938em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mclose mtight">]</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>因此我们可以把 <strong>乘于的每种系数提出来单独讨论</strong>，即分成11种情况来讨论。</p>
<p>设 **F<sub>i,j </sub>**为 <strong>每个数乘于10<sup>i</sup>与k取模后等于j的个数</strong>，ans为总拼法。那么就有：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>=</mo><mi>a</mi><mi>n</mi><mi>s</mi><mo>+</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo stretchy="false">[</mo><mtext> </mtext><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub><mi>a</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mtext> </mtext><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mtext> </mtext><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mtext> </mtext><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub><mi>a</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">)</mo><mtext> </mtext><mi mathvariant="normal">%</mi><mtext> </mtext><mi>k</mi><mtext> </mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">ans=ans+cnt[\ log_{10}a[j]\ ][\ (a[i]\  × 10^{log_{10}a[j]}) \ \% \ k \ ]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace"> </span><span class="mclose">]</span><span class="mopen">[</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mathdefault mtight">a</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">]</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord">%</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace"> </span><span class="mclose">]</span></span></span></span></span></p>
<p>其中 i&lt;j ,<strong>a[i]为高位部分，a[j]为低位部分</strong>。</p>
<p>而根据上述等式，我们根本不需要知道a[i]的数值，只需要处理 a[j] 本身的位数对模数的影响就可以了，推导过程如下：</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \
 at position 185: …\ \%\ k)\ \%\ k\̲
̲'>(a[i]\  × 10^{log_{10}a[j]}\ +\ a[j]) \ \% \ k \ =\ 0 \\
(a[i]\  × 10^{log_{10}a[j]})\ \% \ k\ \ =\ -a[j] \ \% \ k \\
(a[i]\  × 10^{log_{10}a[j]})\ \% \ k\ \ =\ (k-a[j] \ \%\ k)\ \%\ k\
</p>
<p>这样，我们就可以用 <strong>( k - a[j]  % k)  % k</strong>代替 <strong>10<sup>log<sub>10</sub>a[j]</sup></strong> 。解决需要两个变量的问题。</p>
<p>当然，上述做法只能完成**a[i]&lt;a[j]**时，即:a[i]a[j]的拼接情况，不能解决a[j]a[i]的拼接情况。</p>
<p>解决方式也十分简单，让序列反过来按上述流程再说一遍就好了。</p>
<h4 id="代码">代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">20</span>][N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line">LL ans;</span><br><span class="line"><span class="keyword">int</span> n,k; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">log_10</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		res++;</span><br><span class="line">		x/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		</span><br><span class="line">		ans+=f[log_10(a[i])][(k-a[i]%k)%k];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,index = <span class="number">1</span>;j&lt;<span class="number">11</span>;j++)&#123;</span><br><span class="line">			f[j][(LL)index*a[i]%k]++;</span><br><span class="line">			index=(index *<span class="number">10</span>)%k;<span class="comment">//其实直接index*=10好像也可以 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	</span><br><span class="line">	work();</span><br><span class="line">	</span><br><span class="line">	reverse(a,a+n);</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">	</span><br><span class="line">	work();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心习题整理</title>
    <url>/2020/10/12/DSA/BaseAlgotirhm/%E8%B4%AA%E5%BF%83%E4%B9%A0%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>DP虽无固定套路，但起码还有点思维套路可言。我们可以通过积累一定的经典例题去推导出状态转移方程。</p>
<p>而贪心就真的很玄学，大部分情况下需要靠直觉去猜。而猜出结论后，证明难度往往也是大到让人怀疑人生，考场上几乎无证明出来可能~~（如有大佬可以，请受小弟一拜）~~。</p>
<p>对与错，除了交给测评机外验证外，只能靠找反例来验证，极度玄学。。。。。。</p>
<p>结合以上叙述的种种，本蒟蒻唯有靠积累做贪心的经验、加强数学思维锻炼，以增强自身直觉能力一途可走。</p>
<p>以下为本人做过的贪心习题记录与我自己写的题解分析总结。</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.acwing.com/problem/content/1057/">Acwing 1055. 股票买卖 II</a></p>
<p><a href="https://www.acwing.com/problem/content/106/">Acwing 104.货仓选址</a></p>
<p><a href="https://www.acwing.com/problem/content/124/">Acwing 122.糖果传递</a></p>
<p><a href="https://www.acwing.com/problem/content/114/">Acwing 112. 雷达设备</a></p>
<p><a href="https://www.acwing.com/problem/content/1241/">Acwing 1239.乘积最大</a></p>
<p><a href="https://www.acwing.com/problem/content/1249/">Acwing 1247.后缀表达式</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯 分巧克力</title>
    <url>/2020/10/08/Solution/LanQiao/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E5%88%86%E5%B7%A7%E5%85%8B%E5%8A%9B/</url>
    <content><![CDATA[<p><a href="https://www.acwing.com/problem/content/1229/">题目链接</a></p>
<h4 id="问题描述">问题描述</h4>
<p>儿童节那天有 K 位小朋友到小明家做客。</p>
<p>小明拿出了珍藏的巧克力招待小朋友们。</p>
<p>小明一共有 N 块巧克力，其中第 i 块是 H<sub>i</sub>×W<sub>i</sub> 的方格组成的长方形。</p>
<p>为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。</p>
<p>切出的巧克力需要满足：</p>
<ol>
<li>形状是正方形，边长是整数</li>
<li>大小相同</li>
</ol>
<p>例如一块 6×5 的巧克力可以切出 6 块 2×2 的巧克力或者 2 块 3×3 的巧克力。</p>
<p>当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？</p>
<a id="more"></a>
<h4 id="输入格式">输入格式</h4>
<p>第一行包含两个整数 N 和 K。</p>
<p>以下 N 行每行包含两个整数H<sub>i</sub>和W<sub>i</sub> 。</p>
<p>输入保证每位小朋友至少能获得一块1×1 的巧克力。</p>
<h4 id="输出格式">输出格式</h4>
<p>输出切出的正方形巧克力最大可能的边长。</p>
<h4 id="数据范围">数据范围</h4>
<p>1 ≤ N,K ≤10<sup>5</sup><br>
1 ≤ H<sub>i</sub>,W<sub>i</sub> ≤ 10<sup>5</sup></p>
<h3 id="分析">分析</h3>
<p>这题好像还算挺裸的一道二分查找问题。因为题目要求分得的最大边长，但看完题目除了枚举试最大边长外并无他法。而<strong>Max(N)=1e5</strong>，纯暴力试错的最坏情况是O(n<sup>2</sup>)，明显不行。那么想到用二分就是比较顺其自然的事情了。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/20210309051502.jpg" alt="配图（1）"></p>
<p>而很显然，当边长d越大，能得到的总和块数S就越少。设f(d)为边长为d时分得的块数，即有：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>f</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">)</mo><mo>≥</mo><mi>k</mi><mo stretchy="false">)</mo><mspace width="1em"/><mi>L</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi><mspace linebreak="newline"></mspace><mi>e</mi><mi>l</mi><mi>s</mi><mi>e</mi><mspace width="1em"/><mi>R</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">if(f(mid) ≥ k)\quad L=mid\\
else \quad R=mid-1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<h4 id="代码">代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],w[N];</span><br><span class="line"><span class="keyword">int</span> n,k; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(x&gt;w[i]||x&gt;h[i])<span class="keyword">continue</span>;</span><br><span class="line">		ans+= (w[i]/x) * (h[i]/x);</span><br><span class="line">		<span class="keyword">if</span>(ans&gt;=k)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;h[i]&gt;&gt;w[i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">1e5</span>;</span><br><span class="line">	<span class="keyword">int</span> mid;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">		mid = l+r+<span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid))l=mid;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯 k倍区间</title>
    <url>/2020/10/08/Solution/LanQiao/%E8%93%9D%E6%A1%A5%E6%9D%AF-k%E5%80%8D%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<p><a href="https://www.acwing.com/problem/content/1232/">题目链接</a></p>
<h3 id="问题描述">问题描述</h3>
<p>给定一个长度为 N的数列，A<sub>1</sub>,A<sub>2</sub>,…A<sub>N</sub>，如果其中一段连续的子序列 A<sub>i</sub>,A<sub>i+1</sub>,…A<sub>j</sub>之和是 K的倍数，我们就称这个区间 【i,j】 是 K倍区间。</p>
<p>你能求出数列中总共有多少个 K 倍区间吗？</p>
<a id="more"></a>
<h4 id="输入格式">输入格式</h4>
<p>输出一个整数，代表 K倍区间的数目。</p>
<h4 id="数据范围">数据范围</h4>
<p>1 ≤ N , K ≤ 100000<br>
1 ≤ A<sub>i</sub> ≤100000</p>
<h3 id="分析">分析</h3>
<p>首先看到 Max(N)=1e5 ,可以判断出这题时间复杂度需在O(NlogN)以内。</p>
<p>题目问的是子序列和是k的倍数的个数。那么很容易想到枚举所有区间的子序和的暴力做法。纯暴力的话时间复杂度为O(n<sup>3</sup>)，经过简单的前缀和优化后能做到O(n<sup>2</sup>)，虽然还不能<strong>AC</strong>此题，但可以先写出来，再慢慢想优化问题。</p>
<h4 id="暴力源码">暴力源码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>;</span><br><span class="line">LL n,k;</span><br><span class="line">LL a[N];</span><br><span class="line"><span class="comment">//纯暴力做法:枚举起始位置、终点位置后，再用一重循环求得子序和</span></span><br><span class="line"><span class="function">LL <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> R=<span class="number">1</span>;R&lt;=n;R++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> L=<span class="number">1</span>;L&lt;=R;L++)&#123;</span><br><span class="line">			LL sum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=L;k&lt;=R;k++)sum=sum+a[k];</span><br><span class="line">			<span class="keyword">if</span>(sum%k==<span class="number">0</span>)ans++; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单前缀和优化：省去求得子序和的循环</span></span><br><span class="line"><span class="function">LL <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> R=<span class="number">1</span>;R&lt;=n;R++)&#123;</span><br><span class="line">		LL sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> L=<span class="number">1</span>;L&lt;=R;L++)&#123;</span><br><span class="line">			sum=(sum+a[L])%k;</span><br><span class="line">			<span class="keyword">if</span>(sum%k==<span class="number">0</span>)ans++; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"><span class="comment">//   cout&lt;&lt;fun1()&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;fun2()&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>在以上认知的基础上，要想再优化，那么就只能从第二重循环下手了。</p>
<p>对于第二重循环的作用，我们可以理解为是：<strong>在R固定的情况下，在【1，R】中有多少个L满足:</strong></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">[</mo><mi>R</mi><mo stretchy="false">]</mo><mo>−</mo><mi>s</mi><mo stretchy="false">[</mo><mi>L</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>k</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(s[R]-s[L-1])\%k=0
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p>
<p>根据同余定理，我们可以得到下面的等式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mi>R</mi><mo stretchy="false">]</mo><mi mathvariant="normal">%</mi><mi>k</mi><mo>−</mo><mi>s</mi><mo stretchy="false">[</mo><mi>L</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mi mathvariant="normal">%</mi><mi>k</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">s[R]\%k-s[L-1]\%k=0
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">]</span><span class="mord">%</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord">%</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p>
<p>等价于</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">[</mo><mi>R</mi><mo stretchy="false">]</mo><mi mathvariant="normal">%</mi><mi>k</mi><mo>=</mo><mi>s</mi><mo stretchy="false">[</mo><mi>L</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mi mathvariant="normal">%</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">s[R]\%k = s[L-1]\%k
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">]</span><span class="mord">%</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord">%</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></span></p>
<p>所以，我们只要统计一下,在R固定的情况下，【1，R】中有多少个s[L-1]与k取模后，与<strong>S[R]%k</strong>得到的数相同即可，这个操作过程是O(1)的，固可以再优化一重循环。</p>
<p>最后值得注意的是，因为模为0的情况下不需要有跟其它前缀和配对即可确认，因此为了书写形式的统一性，我们可以先让Mod[0]=1。</p>
<h4 id="优化源码">优化源码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>;</span><br><span class="line">LL a[N],Mod[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	Mod[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		a[i]=(a[i]+a[i<span class="number">-1</span>])%k;</span><br><span class="line">		ans+=Mod[a[i]];</span><br><span class="line">		Mod[a[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="写法二">写法二</h4>
<p>整体原理跟上面相同，都是先求得子序的余数情况。不同的是，这里是利用组合数公式来求得不同余数情况的配对总数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>;</span><br><span class="line">LL a[N],Mod[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	Mod[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		a[i]=(a[i]+a[i<span class="number">-1</span>])%k;</span><br><span class="line">		Mod[a[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">		ans+=(Mod[i])*(Mod[i]<span class="number">-1</span>)/<span class="number">2</span>;<span class="comment">//组合数公式c(n,2)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP之信息的表示和处理</title>
    <url>/2020/10/08/ComputerBase/Organization/CSAPP%E4%B9%8B%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>这章很有意思，它深入浅出的讲述了信息在计算机中的表示方式。</p>
<p>通过图像形象生动的展现了底层运算过程中存在的问题。</p>
<p>并在相关知识点最后给出了对应的应用场景和习题令读者加深理解。</p>
<p>以下为本人对本章的学习笔记</p>
</blockquote>
<a id="more"></a>
<h2 id="思维导图">思维导图</h2>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/20210309050829.png" alt="信息的表示和处理"></p>
<h2 id="笔记">笔记</h2>
<h3 id="2-1-信息存储">2.1、信息存储</h3>
<h4 id="2-1-1-字数据大小">2.1.1、字数据大小</h4>
<p><strong>定义</strong>：每台计算机都有一个<strong>字长</strong>(word size),指明指针数据的标称大小。</p>
<p>我们常常说一个计算机是32位的、64位的，说的就是计算机的字长。</p>
<img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/20210309051053.png" alt="2.1.1、字看数据大小" style="zoom:50%;" />
<p>（我的PC是64位，所以上图代码输出的指针占8个byte，即64位）</p>
<p>而因为32位的二进制有4294967296种状态，即:2<sup>32</sup>=4GB。所以32字长的计算机可以控制的<strong>虚拟地址</strong>上限为4GB。其他字长的计算机可控虚拟地址上限同理可得。</p>
<h4 id="2-1-2-字节顺序">2.1.2、字节顺序</h4>
<p>计算机的内存空间划分成若干个连续字节，而我们想表示的数据很多时候不是一个字节就可以表示的。那么对于跨越多个字节的数据或者说对象，组成它的每个字节的存储顺序就有了讨论的必要。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/20210309051113.png" alt="2.1.2、大小端问题"></p>
<p>如上图，是<strong>0x1234567</strong>的两种表示方式。其中：</p>
<ul>
<li><strong>大端法</strong>，跟我们人的使用习惯一样。最高有效位在最左边。</li>
<li><strong>小端法</strong>：则相反，最低有效位在最左边。</li>
</ul>
<p>这两种表示方法没有优劣之分，这是计算机设计者、生产产商的选择问题。</p>
<p>现今，大多数的Intel兼容机都只用小端，IBM和Oracle的大多数都用大端。</p>
<p>对于偶们程序猿来说，真正需要注意到大、小端问题的，大概也只有当两台采用了不同方案表示字节顺序的机器间进行数据传输时了。不过俗话说，前人栽树后人乘凉，除非要自己定制一套两台机器间的传输标准，不然大概率上我们只需要调用前辈们写好的API就好了。</p>
<h4 id="2-1-3-位级运算">2.1.3、位级运算</h4>
<p>这里讨论的位级运算主要以c语言的位级运算作为例子。</p>
<p>对于任一位向量a，都有$ a \oplus a = 0 $。这是个很有意思的性质，利用这个性质，我们可以玩出很多不同的花样。</p>
<h5 id="例1：交换两个变量">例1：交换两个变量</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x,<span class="keyword">int</span> *y)</span></span>&#123;</span><br><span class="line">	*y = *x ^ *y;	<span class="comment">//step 1　ｐｐ</span></span><br><span class="line">	*x = *x ^ *y;	<span class="comment">//step 2</span></span><br><span class="line">	*y = *x ^ *y;	<span class="comment">//step 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然上述交换两个变量的方式跟普通的利用第三变量交换两个数的方式相比没有性能上的优势，但确实一个见识<strong>a^a==0</strong>性质作用的一个好例子。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/20210309051159.jpg" alt="位运算——交换变量"></p>
<p>（因为我比较懒，所以没有画图，直接拍照了 dog.jpg）</p>
<p>上图第2步中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*x = *x ^ *y;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">*x = a ^ a ^ b;</span><br><span class="line"><span class="comment">//根据a^a==0的性质，即：</span></span><br><span class="line">*x = <span class="number">0</span> ^ b == b</span><br><span class="line"><span class="comment">//而*y没有变，依然等于a^b</span></span><br></pre></td></tr></table></figure>
<p>第3步同理可得:*<strong>y = a</strong>。</p>
<hr>
<p>而让我觉得更有意思的是书上后面紧跟着的练习题2.13</p>
<h5 id="练习题2-13">练习题2.13</h5>
<p>20世纪七八十年代一种非常流行的机型，没有布尔、and、or指令。只有<strong>bis(位设置)<strong>和</strong>bic(位清除)<strong>两个指令。现在，只给我们这</strong>bis</strong>和<strong>bic</strong>这两个操作函数，在不能使用任何其他C语言运算的情况下，实现 ”|“或 操作和 ”^“异或 操作。</p>
<p>其中bis和bic具体运算操作和作用如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bis</span><span class="params">(<span class="keyword">int</span> x ,<span class="keyword">int</span> m)</span></span>;	<span class="comment">//位设置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bic</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> m)</span></span>;	<span class="comment">//位清除</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	其中x为输入数据字，m为掩码返回值为z。</span></span><br><span class="line"><span class="comment">	z为x根据掩码m修改后的值。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	bis：在m为1的每个位置上，将z对应的位置设置为1。</span></span><br><span class="line"><span class="comment">	bic：在m为1的每个位置上，将z对应的位置设置为0。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>实现以下函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bool_or</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = _____________;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bool_xor</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = _____________;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>横线处填对应的答案。</p>
<h5 id="分析">分析</h5>
<p>对于bis函数：</p>
<ul>
<li>当m的位为1时，z的对应位为1</li>
<li>当m的位为0时，z的对应位为x的对应位
<ul>
<li>x的对应位为0或1</li>
</ul>
</li>
</ul>
<p>由以上分析可得，bis(位设置)其实就是一个<strong>或运算</strong>。</p>
<p>所以，<strong>bool_or</strong>函数的空处应该直接写  <strong>bis(x,y)</strong> 即可。</p>
<hr>
<p>对于bic函数：</p>
<ul>
<li>当m的位为1时，z的对应位为0</li>
<li>当m的位为0时，z的对应位为x的对应位
<ul>
<li>x的对应位为0或1</li>
</ul>
</li>
</ul>
<p>类比对bis函数的分析，我们看看<strong>与运算</strong>。</p>
<p>当 $ A &amp; B $  时，我们可以把 $ B $  看作掩码  $ m $ ,所以对于<strong>与运算</strong>：</p>
<ul>
<li>当m的位为0时，z的对应位为0</li>
<li>当m的位为1时，z的对应位为x的对应位
<ul>
<li>x的对应位为0或1</li>
</ul>
</li>
</ul>
<p>由上述分析，得到下面式子：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>i</mi><mi>s</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mtext> </mtext><mo>=</mo><mtext> </mtext><mi>A</mi><mtext> </mtext><mi mathvariant="normal">&amp;</mi><mtext> </mtext><mo>∼</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">bis(A,B)\ =\ A\  \&amp; \ \sim B
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace"> </span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></span></p>
<p>可以看出bic函数的本质其实是 <strong>与</strong> 和 <strong>取反</strong> 的组合运算！所以对于第二个填空，即要求我们用 <strong>或</strong> 、 <strong>与</strong> 和 <strong>取反</strong> 的组合运算 实现一个异或。</p>
<p>若已经知道异或的<strong>与或非表达式</strong>的话，就可以直接写出答案了。在这里我们假设不知道异或的 与或非表达式的情况下，类比上面的方式分析推导一下公式。而上述方式其实就是数字逻辑中的利用真值表推出表达式，所以，我们可以得出下图：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/20210309051228.png" alt="异或推导真值表"></p>
<p>由上图，我们可以很清晰的看到 $ A \oplus B $与其他三个式子间的关系。所以我们很容易得到下面的式子：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊕</mo><mi>B</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><mi>b</mi><mi>i</mi><mi>c</mi><mo stretchy="false">(</mo><mtext> </mtext><mi>b</mi><mi>i</mi><mi>s</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mtext> </mtext><mo separator="true">,</mo><mtext> </mtext><mi>b</mi><mi>i</mi><mi>s</mi><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo><mtext> </mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \oplus B\  =\ bic(\ bis(A,B)\ ,\ bis(B,A)\ )
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mspace"> </span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace"> </span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace"> </span><span class="mclose">)</span></span></span></span></span></p>
<h6 id="小结">小结</h6>
<p>以上关系推导的最优解法其实是直接列出真值表即可清晰明了的看出各种运算符间的关系表达式。纯数学表达式推导在逻辑运算中不太好使。</p>
<h4 id="2-1-4-移位运算">2.1.4、移位运算</h4>
<p>移位运算没啥东西，需要关注的主要在于右移上。</p>
<ul>
<li>逻辑右移：左端最高位补0</li>
<li>算术右移：左端最高位补原最高位的数</li>
</ul>
<p>而由于为了保证不同机器间代码的可移植性，现在几乎所有编译器都采用算术右移（c语言没有明确规定有符号数应该采用哪种右移方式），所以对于这块只需有个印象即可。</p>
<h3 id="2-2-整数的表示">2.2、整数的表示</h3>
<p>我们可以把整数的位级表示看成一个 $ ω $ 位的向量 $ \vec{x} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>。</mtext></mrow><annotation encoding="application/x-tex">。</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">。</span></span></span></span> \vec{x} \ =[ x_{ω-1},x_{ω-2},…,x_{0} ]$</p>
<h4 id="2-2-1-无符号整数表示">2.2.1、无符号整数表示</h4>
<p>无符号整数跟正常的非负数的二进制表示一样，为了与后面讨论保持一致性，下面给出无符号整数的数学表达：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mn>2</mn><msub><mi>U</mi><mi>ω</mi></msub><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>ω</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>x</mi><mi>i</mi></msub><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">B2U_ω (\vec{x})=\sum_{i=0}^{ω-1}x_i2^i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">2</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">ω</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">ω</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中 $ B2U_ω (\vec{x}) $ 的值为向量 $ \vec{x} $ 的十进制无符号数表示。</p>
<p>结合下图可形象理解。</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/20210309051250.jpg" alt="源码表示"></p>
<h4 id="2-2-2-有符号数表示">2.2.2、有符号数表示</h4>
<p>有符号数有三种常见的编码表示方式：</p>
<ul>
<li>原码</li>
<li>反码</li>
<li>补码</li>
</ul>
<p>其中现在使用最广泛的是补码，其他两种用的不多，原因在后续会给出。</p>
<h5 id="补码编码定义">补码编码定义</h5>
<p>对于向量$ \vec{x} \ =[ x_{ω-1},x_{ω-2},…,x_{0} ]$：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mn>2</mn><msub><mi>T</mi><mi>ω</mi></msub><mo stretchy="false">(</mo><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><msub><mi>x</mi><mrow><mi>ω</mi><mo>−</mo><mn>1</mn></mrow></msub><msup><mn>2</mn><mrow><mi>ω</mi><mo>−</mo><mn>1</mn></mrow></msup><mtext> </mtext><mo>+</mo><mtext> </mtext><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>ω</mi><mo>−</mo><mn>2</mn></mrow></munderover><msub><mi>x</mi><mi>i</mi></msub><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">B2T_ω (\vec{x})=-x_{ω-1}2^{ω-1}\ +\ \sum_{i=0}^{ω-2}x_i2^i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">2</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">ω</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.072439em;vertical-align:-0.208331em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">ω</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">ω</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span></span><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">ω</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中 $ B2T_ω (\vec{x}) $ 的值为向量 $ \vec{x} $ 的十进制有符号数表示。</p>
<p>图像表示如下：</p>
<p><img src="https://photos-1302100213.cos.ap-guangzhou.myqcloud.com/imgs/Blog/20210309051306.jpg" alt="补码表示"></p>
<p>因为一个整数有正有负，那么我们就需要拿一位来表示这一串01序列表示的数的正负性了。而如果我们随便的指定<strong>最高位的0表示负数/正数，1表示正数/负数</strong>的话，想让计算机理解是有困难的。所以，我们赋予最高有效一个权值 $ -x_{ω-1}2^{ω-1} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo separator="true">,</mo><mtext>这样就可以做到码制和数制的高度统一了。所以最高有效位</mtext></mrow><annotation encoding="application/x-tex">,这样就可以做到 码制和数制的高度统一了。所以最高有效位</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">做</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">码</span><span class="mord cjk_fallback">制</span><span class="mord cjk_fallback">和</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">制</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">高</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">统</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">高</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">效</span><span class="mord cjk_fallback">位</span></span></span></span> x_{ω-1} $ 也称为符号位。</p>
<p>由上图我们也可以看到这种表示方法的边界是不对称性：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>m</mi><mi>i</mi><mi>n</mi><mo>=</mo><mo>−</mo><msup><mn>2</mn><mrow><mi>ω</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">Tmin=-2^{ω-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">ω</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，$ Tmax=2^{ω-1}-1$。</p>
<hr>
<p>未完待续~~~</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>信息表示</tag>
      </tags>
  </entry>
  <entry>
    <title>日期、时间问题整理</title>
    <url>/2020/10/06/Solution/LanQiao/%E6%97%A5%E6%9C%9F%E3%80%81%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="引言">引言</h2>
<blockquote>
<p>日期、时间类的问题，在蓝桥杯中出现的概率貌似还挺高的。</p>
<p>这类问题如果自身码力不够且之前没接触过的话，有一定的翻车概率。</p>
<p>为避免自己在该问题上翻车，特此整理一下。</p>
</blockquote>
<a id="more"></a>
<h2 id="日期问题">日期问题</h2>
<p>对于日期问题，无论它怎么考，有个点肯定是少不了的，那就是判断闰年。虽然这判断的完成难度是语法课级别的，但由于条件容易忘记~~（也许这只是我菜的问题）~~所以我觉得这里还是有必要记录下，以防到时忘记翻车。</p>
<h4 id="闰年判断">闰年判断</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> year)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(year%<span class="number">4</span> == <span class="number">0</span> &amp;&amp; year%<span class="number">100</span> || year%<span class="number">400</span>==<span class="number">0</span> )<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了闰年判断外，这个东西有玩头的莫过于给两个日期，然后问你在这两个日期间有多少符合题目给定的约束条件的、这两个日期间有多少天之类。如果是简单循环模拟的话，其实也不是辣么好写，可能存在一些边界情况。</p>
<p>有一个好的方法是：因为我们使用的日期基本可以认为是8位的。那么我们只需要枚举这日期和终点日期的年、月、日组成的8位数，对于枚举到的每个数，先判断它是否是一个日期，在判断是否是题目所求日期，就可以了。</p>
<h4 id="日期转换">日期转换</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsDate</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(month&gt;<span class="number">12</span> || !month || !day)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!month != <span class="number">2</span> &amp;&amp; days[month]&lt;day )<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(month == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">bool</span> leap = year % <span class="number">4</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">100</span> || year %<span class="number">400</span> == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">28</span>+leap&lt;day)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> date = Date1;date &lt;= Date2; date++)&#123;</span><br><span class="line">    <span class="comment">//提取年、月、日</span></span><br><span class="line">    <span class="keyword">int</span> year = date / <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">int</span> month = (date % <span class="number">10000</span>) / <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> day = date % <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(IsDate(year,month,day))&#123;</span><br><span class="line">        <span class="keyword">if</span>(check(year,month,day))&#123;<span class="comment">//题目约束条件</span></span><br><span class="line">            一般是输出操作，也可能是其他操作。</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子，例如问：2020.9.1到2030.8.1有多少天？就可以把这两个日期转换成8位整数，套用上面的模板。然后搞一个变量放在第18行的位置计数就可以了。（值得注意的是，如果问的是天数，循环终止条件不是’≤’，而是’＜’）</p>
<p>貌似日期问题玩的花样就辣么多吧，比较简单。下面是相关练习题链接</p>
<h4 id="习题">习题</h4>
<p><a href="https://www.acwing.com/problem/content/1231/">acwing 1229.日期问题</a></p>
<p><a href="https://www.acwing.com/problem/content/description/468/">acwing 466. 回文日期</a></p>
<h2 id="时间问题">时间问题</h2>
<p>时间问题大题玩法跟日期问题类型，我们只要简单的把h和min化为seconds统一处理就好了。但因为各国的时区不同，出题人有可能会在这上面做文章，但有常识应该问题也不大，终归还是数学问题。</p>
<p>有意思的是，因为我们日常的时间表示方式的缘故，处理时间问题的难点可能出现在处理字符串上。</p>
<p><strong>习题<a href="https://www.acwing.com/problem/content/description/1233/">acwing 1231. 航班时间</a></strong></p>
<p>就很好的诠释了这点，我个人觉得这题也是一道练习字符串处理的好题。</p>
<p>我写的题解链接如下：</p>
<p><strong><a href="#">acwing 1231.航班问题【题解】</a></strong></p>
<h2 id="小结">小结</h2>
<p>处理诸如日期、时间问题这种由多个不同层级单位组成的数字组合一个常用通用方法是统一单位，都先转化成最小单位。</p>
<p>按问题要求处理完后，再通过层级转换关系恢复原样。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>蓝桥杯</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/10/04/hello-world/</url>
    <content><![CDATA[<p>这大概算是我第一次建站吧，瞎搞了两三天，一步一个坑的终于把它部署好了。当我输入自定义的域名，Chrome成功加载出页面那一刻，感觉一切都值了！</p>
<a id="more"></a>
<p>以前虽然也想过自己搭建一个Blog写博文，但当时过于心浮气躁，没能沉下心研究怎么建站，就随便在博客园上申请了个账号，佛系的时不时写几篇博文，*<s>(果然容易得到的就是不知道珍惜啊)</s>*也没啥长进。</p>
<p>况且脑子里一直有个声音**搞技术的怎么可以没有一个自己搭的个站呢？**于是，在种种原因下，这次终于把个站搞起来了。</p>
<p>88大洋买了3年的域名，跟过去说88。日后戒骄戒躁，脚踏实地努力修仙。</p>
<p>今后会在本站写一些平时的学习笔记和随想，亦或是一些个人项目展示。</p>
<p><strong>祝我早日技术自由</strong></p>
]]></content>
  </entry>
</search>
